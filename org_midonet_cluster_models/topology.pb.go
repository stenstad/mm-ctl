// Code generated by protoc-gen-go.
// source: topology.proto
// DO NOT EDIT!

package org_midonet_cluster_models

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// One per type
type Type int32

const (
	Type_BGP_NETWORK    Type = 1
	Type_BGP_PEER       Type = 2
	Type_CHAIN          Type = 3
	Type_DHCP           Type = 4
	Type_DHCP_V6        Type = 5
	Type_HEALTH_MONITOR Type = 6
	Type_HOST           Type = 7
	Type_IP_ADDR_GROUP  Type = 8
	Type_LOAD_BALANCER  Type = 9
	Type_NETWORK        Type = 10
	Type_POOL           Type = 11
	Type_POOL_MEMBER    Type = 12
	Type_PORT           Type = 13
	Type_PORT_GROUP     Type = 14
	Type_ROUTE          Type = 15
	Type_ROUTER         Type = 16
	Type_RULE           Type = 17
	Type_TRACE_REQUEST  Type = 18
	Type_TUNNEL_ZONE    Type = 19
	Type_VIP            Type = 20
	Type_VTEP           Type = 21
	Type_MIRROR         Type = 22
	Type_L2INSERTION    Type = 31
)

var Type_name = map[int32]string{
	1:  "BGP_NETWORK",
	2:  "BGP_PEER",
	3:  "CHAIN",
	4:  "DHCP",
	5:  "DHCP_V6",
	6:  "HEALTH_MONITOR",
	7:  "HOST",
	8:  "IP_ADDR_GROUP",
	9:  "LOAD_BALANCER",
	10: "NETWORK",
	11: "POOL",
	12: "POOL_MEMBER",
	13: "PORT",
	14: "PORT_GROUP",
	15: "ROUTE",
	16: "ROUTER",
	17: "RULE",
	18: "TRACE_REQUEST",
	19: "TUNNEL_ZONE",
	20: "VIP",
	21: "VTEP",
	22: "MIRROR",
	31: "L2INSERTION",
}
var Type_value = map[string]int32{
	"BGP_NETWORK":    1,
	"BGP_PEER":       2,
	"CHAIN":          3,
	"DHCP":           4,
	"DHCP_V6":        5,
	"HEALTH_MONITOR": 6,
	"HOST":           7,
	"IP_ADDR_GROUP":  8,
	"LOAD_BALANCER":  9,
	"NETWORK":        10,
	"POOL":           11,
	"POOL_MEMBER":    12,
	"PORT":           13,
	"PORT_GROUP":     14,
	"ROUTE":          15,
	"ROUTER":         16,
	"RULE":           17,
	"TRACE_REQUEST":  18,
	"TUNNEL_ZONE":    19,
	"VIP":            20,
	"VTEP":           21,
	"MIRROR":         22,
	"L2INSERTION":    31,
}

func (x Type) Enum() *Type {
	p := new(Type)
	*p = x
	return p
}
func (x Type) String() string {
	return proto.EnumName(Type_name, int32(x))
}
func (x *Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Type_value, data, "Type")
	if err != nil {
		return err
	}
	*x = Type(value)
	return nil
}
func (Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

type HealthMonitor_HealthMonitorType int32

const (
	HealthMonitor_TCP HealthMonitor_HealthMonitorType = 1
)

var HealthMonitor_HealthMonitorType_name = map[int32]string{
	1: "TCP",
}
var HealthMonitor_HealthMonitorType_value = map[string]int32{
	"TCP": 1,
}

func (x HealthMonitor_HealthMonitorType) Enum() *HealthMonitor_HealthMonitorType {
	p := new(HealthMonitor_HealthMonitorType)
	*p = x
	return p
}
func (x HealthMonitor_HealthMonitorType) String() string {
	return proto.EnumName(HealthMonitor_HealthMonitorType_name, int32(x))
}
func (x *HealthMonitor_HealthMonitorType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(HealthMonitor_HealthMonitorType_value, data, "HealthMonitor_HealthMonitorType")
	if err != nil {
		return err
	}
	*x = HealthMonitor_HealthMonitorType(value)
	return nil
}
func (HealthMonitor_HealthMonitorType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor1, []int{5, 0}
}

type Pool_PoolProtocol int32

const (
	Pool_TCP Pool_PoolProtocol = 1
)

var Pool_PoolProtocol_name = map[int32]string{
	1: "TCP",
}
var Pool_PoolProtocol_value = map[string]int32{
	"TCP": 1,
}

func (x Pool_PoolProtocol) Enum() *Pool_PoolProtocol {
	p := new(Pool_PoolProtocol)
	*p = x
	return p
}
func (x Pool_PoolProtocol) String() string {
	return proto.EnumName(Pool_PoolProtocol_name, int32(x))
}
func (x *Pool_PoolProtocol) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Pool_PoolProtocol_value, data, "Pool_PoolProtocol")
	if err != nil {
		return err
	}
	*x = Pool_PoolProtocol(value)
	return nil
}
func (Pool_PoolProtocol) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{12, 0} }

type Pool_PoolLBMethod int32

const (
	Pool_ROUND_ROBIN Pool_PoolLBMethod = 1
)

var Pool_PoolLBMethod_name = map[int32]string{
	1: "ROUND_ROBIN",
}
var Pool_PoolLBMethod_value = map[string]int32{
	"ROUND_ROBIN": 1,
}

func (x Pool_PoolLBMethod) Enum() *Pool_PoolLBMethod {
	p := new(Pool_PoolLBMethod)
	*p = x
	return p
}
func (x Pool_PoolLBMethod) String() string {
	return proto.EnumName(Pool_PoolLBMethod_name, int32(x))
}
func (x *Pool_PoolLBMethod) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Pool_PoolLBMethod_value, data, "Pool_PoolLBMethod")
	if err != nil {
		return err
	}
	*x = Pool_PoolLBMethod(value)
	return nil
}
func (Pool_PoolLBMethod) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{12, 1} }

type Pool_PoolHealthMonitorMappingStatus int32

const (
	Pool_ACTIVE         Pool_PoolHealthMonitorMappingStatus = 1
	Pool_INACTIVE       Pool_PoolHealthMonitorMappingStatus = 2
	Pool_PENDING_CREATE Pool_PoolHealthMonitorMappingStatus = 3
	Pool_PENDING_UPDATE Pool_PoolHealthMonitorMappingStatus = 4
	Pool_PENDING_DELETE Pool_PoolHealthMonitorMappingStatus = 5
	Pool_ERROR          Pool_PoolHealthMonitorMappingStatus = 6
)

var Pool_PoolHealthMonitorMappingStatus_name = map[int32]string{
	1: "ACTIVE",
	2: "INACTIVE",
	3: "PENDING_CREATE",
	4: "PENDING_UPDATE",
	5: "PENDING_DELETE",
	6: "ERROR",
}
var Pool_PoolHealthMonitorMappingStatus_value = map[string]int32{
	"ACTIVE":         1,
	"INACTIVE":       2,
	"PENDING_CREATE": 3,
	"PENDING_UPDATE": 4,
	"PENDING_DELETE": 5,
	"ERROR":          6,
}

func (x Pool_PoolHealthMonitorMappingStatus) Enum() *Pool_PoolHealthMonitorMappingStatus {
	p := new(Pool_PoolHealthMonitorMappingStatus)
	*p = x
	return p
}
func (x Pool_PoolHealthMonitorMappingStatus) String() string {
	return proto.EnumName(Pool_PoolHealthMonitorMappingStatus_name, int32(x))
}
func (x *Pool_PoolHealthMonitorMappingStatus) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Pool_PoolHealthMonitorMappingStatus_value, data, "Pool_PoolHealthMonitorMappingStatus")
	if err != nil {
		return err
	}
	*x = Pool_PoolHealthMonitorMappingStatus(value)
	return nil
}
func (Pool_PoolHealthMonitorMappingStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor1, []int{12, 2}
}

type Route_NextHop int32

const (
	Route_BLACKHOLE Route_NextHop = 0
	Route_REJECT    Route_NextHop = 1
	Route_PORT      Route_NextHop = 2
	Route_LOCAL     Route_NextHop = 3
)

var Route_NextHop_name = map[int32]string{
	0: "BLACKHOLE",
	1: "REJECT",
	2: "PORT",
	3: "LOCAL",
}
var Route_NextHop_value = map[string]int32{
	"BLACKHOLE": 0,
	"REJECT":    1,
	"PORT":      2,
	"LOCAL":     3,
}

func (x Route_NextHop) Enum() *Route_NextHop {
	p := new(Route_NextHop)
	*p = x
	return p
}
func (x Route_NextHop) String() string {
	return proto.EnumName(Route_NextHop_name, int32(x))
}
func (x *Route_NextHop) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Route_NextHop_value, data, "Route_NextHop")
	if err != nil {
		return err
	}
	*x = Route_NextHop(value)
	return nil
}
func (Route_NextHop) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{16, 0} }

type Rule_Type int32

const (
	Rule_LITERAL_RULE     Rule_Type = 1
	Rule_NAT_RULE         Rule_Type = 2
	Rule_JUMP_RULE        Rule_Type = 3
	Rule_TRACE_RULE       Rule_Type = 4
	Rule_L2TRANSFORM_RULE Rule_Type = 5
)

var Rule_Type_name = map[int32]string{
	1: "LITERAL_RULE",
	2: "NAT_RULE",
	3: "JUMP_RULE",
	4: "TRACE_RULE",
	5: "L2TRANSFORM_RULE",
}
var Rule_Type_value = map[string]int32{
	"LITERAL_RULE":     1,
	"NAT_RULE":         2,
	"JUMP_RULE":        3,
	"TRACE_RULE":       4,
	"L2TRANSFORM_RULE": 5,
}

func (x Rule_Type) Enum() *Rule_Type {
	p := new(Rule_Type)
	*p = x
	return p
}
func (x Rule_Type) String() string {
	return proto.EnumName(Rule_Type_name, int32(x))
}
func (x *Rule_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Rule_Type_value, data, "Rule_Type")
	if err != nil {
		return err
	}
	*x = Rule_Type(value)
	return nil
}
func (Rule_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{18, 0} }

type Rule_Action int32

const (
	Rule_ACCEPT   Rule_Action = 1
	Rule_CONTINUE Rule_Action = 2
	Rule_DROP     Rule_Action = 3
	Rule_JUMP     Rule_Action = 4
	Rule_REJECT   Rule_Action = 5
	Rule_RETURN   Rule_Action = 6
	Rule_REDIRECT Rule_Action = 7
)

var Rule_Action_name = map[int32]string{
	1: "ACCEPT",
	2: "CONTINUE",
	3: "DROP",
	4: "JUMP",
	5: "REJECT",
	6: "RETURN",
	7: "REDIRECT",
}
var Rule_Action_value = map[string]int32{
	"ACCEPT":   1,
	"CONTINUE": 2,
	"DROP":     3,
	"JUMP":     4,
	"REJECT":   5,
	"RETURN":   6,
	"REDIRECT": 7,
}

func (x Rule_Action) Enum() *Rule_Action {
	p := new(Rule_Action)
	*p = x
	return p
}
func (x Rule_Action) String() string {
	return proto.EnumName(Rule_Action_name, int32(x))
}
func (x *Rule_Action) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Rule_Action_value, data, "Rule_Action")
	if err != nil {
		return err
	}
	*x = Rule_Action(value)
	return nil
}
func (Rule_Action) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{18, 1} }

type TunnelZone_Type int32

const (
	TunnelZone_GRE   TunnelZone_Type = 1
	TunnelZone_VXLAN TunnelZone_Type = 2
	TunnelZone_VTEP  TunnelZone_Type = 3
)

var TunnelZone_Type_name = map[int32]string{
	1: "GRE",
	2: "VXLAN",
	3: "VTEP",
}
var TunnelZone_Type_value = map[string]int32{
	"GRE":   1,
	"VXLAN": 2,
	"VTEP":  3,
}

func (x TunnelZone_Type) Enum() *TunnelZone_Type {
	p := new(TunnelZone_Type)
	*p = x
	return p
}
func (x TunnelZone_Type) String() string {
	return proto.EnumName(TunnelZone_Type_name, int32(x))
}
func (x *TunnelZone_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TunnelZone_Type_value, data, "TunnelZone_Type")
	if err != nil {
		return err
	}
	*x = TunnelZone_Type(value)
	return nil
}
func (TunnelZone_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{20, 0} }

type Vip_SessionPersistence int32

const (
	Vip_SOURCE_IP Vip_SessionPersistence = 1
)

var Vip_SessionPersistence_name = map[int32]string{
	1: "SOURCE_IP",
}
var Vip_SessionPersistence_value = map[string]int32{
	"SOURCE_IP": 1,
}

func (x Vip_SessionPersistence) Enum() *Vip_SessionPersistence {
	p := new(Vip_SessionPersistence)
	*p = x
	return p
}
func (x Vip_SessionPersistence) String() string {
	return proto.EnumName(Vip_SessionPersistence_name, int32(x))
}
func (x *Vip_SessionPersistence) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Vip_SessionPersistence_value, data, "Vip_SessionPersistence")
	if err != nil {
		return err
	}
	*x = Vip_SessionPersistence(value)
	return nil
}
func (Vip_SessionPersistence) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{21, 0} }

type BgpNetwork struct {
	Id     *UUID     `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Subnet *IPSubnet `protobuf:"bytes,2,opt,name=subnet" json:"subnet,omitempty"`
	// Backreference
	RouterId         *UUID  `protobuf:"bytes,3,opt,name=router_id" json:"router_id,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *BgpNetwork) Reset()                    { *m = BgpNetwork{} }
func (m *BgpNetwork) String() string            { return proto.CompactTextString(m) }
func (*BgpNetwork) ProtoMessage()               {}
func (*BgpNetwork) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

func (m *BgpNetwork) GetId() *UUID {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *BgpNetwork) GetSubnet() *IPSubnet {
	if m != nil {
		return m.Subnet
	}
	return nil
}

func (m *BgpNetwork) GetRouterId() *UUID {
	if m != nil {
		return m.RouterId
	}
	return nil
}

type BgpPeer struct {
	Id           *UUID      `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	AsNumber     *int32     `protobuf:"varint,2,opt,name=as_number" json:"as_number,omitempty"`
	Address      *IPAddress `protobuf:"bytes,3,opt,name=address" json:"address,omitempty"`
	KeepAlive    *int32     `protobuf:"varint,4,opt,name=keep_alive" json:"keep_alive,omitempty"`
	HoldTime     *int32     `protobuf:"varint,5,opt,name=hold_time" json:"hold_time,omitempty"`
	ConnectRetry *int32     `protobuf:"varint,6,opt,name=connect_retry" json:"connect_retry,omitempty"`
	Password     *string    `protobuf:"bytes,8,opt,name=password" json:"password,omitempty"`
	// Backreference
	RouterId         *UUID  `protobuf:"bytes,7,opt,name=router_id" json:"router_id,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *BgpPeer) Reset()                    { *m = BgpPeer{} }
func (m *BgpPeer) String() string            { return proto.CompactTextString(m) }
func (*BgpPeer) ProtoMessage()               {}
func (*BgpPeer) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{1} }

func (m *BgpPeer) GetId() *UUID {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *BgpPeer) GetAsNumber() int32 {
	if m != nil && m.AsNumber != nil {
		return *m.AsNumber
	}
	return 0
}

func (m *BgpPeer) GetAddress() *IPAddress {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *BgpPeer) GetKeepAlive() int32 {
	if m != nil && m.KeepAlive != nil {
		return *m.KeepAlive
	}
	return 0
}

func (m *BgpPeer) GetHoldTime() int32 {
	if m != nil && m.HoldTime != nil {
		return *m.HoldTime
	}
	return 0
}

func (m *BgpPeer) GetConnectRetry() int32 {
	if m != nil && m.ConnectRetry != nil {
		return *m.ConnectRetry
	}
	return 0
}

func (m *BgpPeer) GetPassword() string {
	if m != nil && m.Password != nil {
		return *m.Password
	}
	return ""
}

func (m *BgpPeer) GetRouterId() *UUID {
	if m != nil {
		return m.RouterId
	}
	return nil
}

type Chain struct {
	Id       *UUID   `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Name     *string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	TenantId *string `protobuf:"bytes,3,opt,name=tenant_id" json:"tenant_id,omitempty"`
	// Backreferences
	RuleIds            []*UUID `protobuf:"bytes,101,rep,name=rule_ids" json:"rule_ids,omitempty"`
	NetworkInboundIds  []*UUID `protobuf:"bytes,102,rep,name=network_inbound_ids" json:"network_inbound_ids,omitempty"`
	NetworkOutboundIds []*UUID `protobuf:"bytes,103,rep,name=network_outbound_ids" json:"network_outbound_ids,omitempty"`
	RouterInboundIds   []*UUID `protobuf:"bytes,104,rep,name=router_inbound_ids" json:"router_inbound_ids,omitempty"`
	RouterOutboundIds  []*UUID `protobuf:"bytes,105,rep,name=router_outbound_ids" json:"router_outbound_ids,omitempty"`
	PortInboundIds     []*UUID `protobuf:"bytes,106,rep,name=port_inbound_ids" json:"port_inbound_ids,omitempty"`
	PortOutboundIds    []*UUID `protobuf:"bytes,107,rep,name=port_outbound_ids" json:"port_outbound_ids,omitempty"`
	JumpRuleIds        []*UUID `protobuf:"bytes,108,rep,name=jump_rule_ids" json:"jump_rule_ids,omitempty"`
	XXX_unrecognized   []byte  `json:"-"`
}

func (m *Chain) Reset()                    { *m = Chain{} }
func (m *Chain) String() string            { return proto.CompactTextString(m) }
func (*Chain) ProtoMessage()               {}
func (*Chain) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{2} }

func (m *Chain) GetId() *UUID {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *Chain) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Chain) GetTenantId() string {
	if m != nil && m.TenantId != nil {
		return *m.TenantId
	}
	return ""
}

func (m *Chain) GetRuleIds() []*UUID {
	if m != nil {
		return m.RuleIds
	}
	return nil
}

func (m *Chain) GetNetworkInboundIds() []*UUID {
	if m != nil {
		return m.NetworkInboundIds
	}
	return nil
}

func (m *Chain) GetNetworkOutboundIds() []*UUID {
	if m != nil {
		return m.NetworkOutboundIds
	}
	return nil
}

func (m *Chain) GetRouterInboundIds() []*UUID {
	if m != nil {
		return m.RouterInboundIds
	}
	return nil
}

func (m *Chain) GetRouterOutboundIds() []*UUID {
	if m != nil {
		return m.RouterOutboundIds
	}
	return nil
}

func (m *Chain) GetPortInboundIds() []*UUID {
	if m != nil {
		return m.PortInboundIds
	}
	return nil
}

func (m *Chain) GetPortOutboundIds() []*UUID {
	if m != nil {
		return m.PortOutboundIds
	}
	return nil
}

func (m *Chain) GetJumpRuleIds() []*UUID {
	if m != nil {
		return m.JumpRuleIds
	}
	return nil
}

type Dhcp struct {
	Id               *UUID               `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	NetworkId        *UUID               `protobuf:"bytes,2,opt,name=network_id" json:"network_id,omitempty"`
	SubnetAddress    *IPSubnet           `protobuf:"bytes,3,opt,name=subnet_address" json:"subnet_address,omitempty"`
	ServerAddress    *IPAddress          `protobuf:"bytes,4,opt,name=server_address" json:"server_address,omitempty"`
	DnsServerAddress []*IPAddress        `protobuf:"bytes,5,rep,name=dns_server_address" json:"dns_server_address,omitempty"`
	DefaultGateway   *IPAddress          `protobuf:"bytes,6,opt,name=default_gateway" json:"default_gateway,omitempty"`
	InterfaceMtu     *int32              `protobuf:"varint,7,opt,name=interface_mtu" json:"interface_mtu,omitempty"`
	Opt121Routes     []*Dhcp_Opt121Route `protobuf:"bytes,8,rep,name=opt121_routes" json:"opt121_routes,omitempty"`
	Hosts            []*Dhcp_Host        `protobuf:"bytes,9,rep,name=hosts" json:"hosts,omitempty"`
	Enabled          *bool               `protobuf:"varint,10,opt,name=enabled" json:"enabled,omitempty"`
	// Router interface port associated with this DHCP.
	RouterIfPortId *UUID `protobuf:"bytes,101,opt,name=router_if_port_id" json:"router_if_port_id,omitempty"`
	// Gateway routes with a gateway via this DHCP.
	GatewayRouteIds  []*UUID `protobuf:"bytes,102,rep,name=gateway_route_ids" json:"gateway_route_ids,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Dhcp) Reset()                    { *m = Dhcp{} }
func (m *Dhcp) String() string            { return proto.CompactTextString(m) }
func (*Dhcp) ProtoMessage()               {}
func (*Dhcp) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{3} }

func (m *Dhcp) GetId() *UUID {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *Dhcp) GetNetworkId() *UUID {
	if m != nil {
		return m.NetworkId
	}
	return nil
}

func (m *Dhcp) GetSubnetAddress() *IPSubnet {
	if m != nil {
		return m.SubnetAddress
	}
	return nil
}

func (m *Dhcp) GetServerAddress() *IPAddress {
	if m != nil {
		return m.ServerAddress
	}
	return nil
}

func (m *Dhcp) GetDnsServerAddress() []*IPAddress {
	if m != nil {
		return m.DnsServerAddress
	}
	return nil
}

func (m *Dhcp) GetDefaultGateway() *IPAddress {
	if m != nil {
		return m.DefaultGateway
	}
	return nil
}

func (m *Dhcp) GetInterfaceMtu() int32 {
	if m != nil && m.InterfaceMtu != nil {
		return *m.InterfaceMtu
	}
	return 0
}

func (m *Dhcp) GetOpt121Routes() []*Dhcp_Opt121Route {
	if m != nil {
		return m.Opt121Routes
	}
	return nil
}

func (m *Dhcp) GetHosts() []*Dhcp_Host {
	if m != nil {
		return m.Hosts
	}
	return nil
}

func (m *Dhcp) GetEnabled() bool {
	if m != nil && m.Enabled != nil {
		return *m.Enabled
	}
	return false
}

func (m *Dhcp) GetRouterIfPortId() *UUID {
	if m != nil {
		return m.RouterIfPortId
	}
	return nil
}

func (m *Dhcp) GetGatewayRouteIds() []*UUID {
	if m != nil {
		return m.GatewayRouteIds
	}
	return nil
}

type Dhcp_Opt121Route struct {
	DstSubnet        *IPSubnet  `protobuf:"bytes,1,opt,name=dst_subnet" json:"dst_subnet,omitempty"`
	Gateway          *IPAddress `protobuf:"bytes,2,opt,name=gateway" json:"gateway,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *Dhcp_Opt121Route) Reset()                    { *m = Dhcp_Opt121Route{} }
func (m *Dhcp_Opt121Route) String() string            { return proto.CompactTextString(m) }
func (*Dhcp_Opt121Route) ProtoMessage()               {}
func (*Dhcp_Opt121Route) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{3, 0} }

func (m *Dhcp_Opt121Route) GetDstSubnet() *IPSubnet {
	if m != nil {
		return m.DstSubnet
	}
	return nil
}

func (m *Dhcp_Opt121Route) GetGateway() *IPAddress {
	if m != nil {
		return m.Gateway
	}
	return nil
}

type Dhcp_Host struct {
	Mac              *string                   `protobuf:"bytes,1,opt,name=mac" json:"mac,omitempty"`
	IpAddress        *IPAddress                `protobuf:"bytes,2,opt,name=ip_address" json:"ip_address,omitempty"`
	Name             *string                   `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
	ExtraDhcpOpts    []*Dhcp_Host_ExtraDhcpOpt `protobuf:"bytes,4,rep,name=extra_dhcp_opts" json:"extra_dhcp_opts,omitempty"`
	XXX_unrecognized []byte                    `json:"-"`
}

func (m *Dhcp_Host) Reset()                    { *m = Dhcp_Host{} }
func (m *Dhcp_Host) String() string            { return proto.CompactTextString(m) }
func (*Dhcp_Host) ProtoMessage()               {}
func (*Dhcp_Host) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{3, 1} }

func (m *Dhcp_Host) GetMac() string {
	if m != nil && m.Mac != nil {
		return *m.Mac
	}
	return ""
}

func (m *Dhcp_Host) GetIpAddress() *IPAddress {
	if m != nil {
		return m.IpAddress
	}
	return nil
}

func (m *Dhcp_Host) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Dhcp_Host) GetExtraDhcpOpts() []*Dhcp_Host_ExtraDhcpOpt {
	if m != nil {
		return m.ExtraDhcpOpts
	}
	return nil
}

type Dhcp_Host_ExtraDhcpOpt struct {
	Name             *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Value            *string `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Dhcp_Host_ExtraDhcpOpt) Reset()                    { *m = Dhcp_Host_ExtraDhcpOpt{} }
func (m *Dhcp_Host_ExtraDhcpOpt) String() string            { return proto.CompactTextString(m) }
func (*Dhcp_Host_ExtraDhcpOpt) ProtoMessage()               {}
func (*Dhcp_Host_ExtraDhcpOpt) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{3, 1, 0} }

func (m *Dhcp_Host_ExtraDhcpOpt) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Dhcp_Host_ExtraDhcpOpt) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

type DhcpV6 struct {
	Id               *UUID          `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	NetworkId        *UUID          `protobuf:"bytes,2,opt,name=network_id" json:"network_id,omitempty"`
	SubnetAddress    *IPSubnet      `protobuf:"bytes,3,opt,name=subnet_address" json:"subnet_address,omitempty"`
	Hosts            []*DhcpV6_Host `protobuf:"bytes,4,rep,name=hosts" json:"hosts,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *DhcpV6) Reset()                    { *m = DhcpV6{} }
func (m *DhcpV6) String() string            { return proto.CompactTextString(m) }
func (*DhcpV6) ProtoMessage()               {}
func (*DhcpV6) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{4} }

func (m *DhcpV6) GetId() *UUID {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *DhcpV6) GetNetworkId() *UUID {
	if m != nil {
		return m.NetworkId
	}
	return nil
}

func (m *DhcpV6) GetSubnetAddress() *IPSubnet {
	if m != nil {
		return m.SubnetAddress
	}
	return nil
}

func (m *DhcpV6) GetHosts() []*DhcpV6_Host {
	if m != nil {
		return m.Hosts
	}
	return nil
}

type DhcpV6_Host struct {
	ClientId         *string    `protobuf:"bytes,1,opt,name=client_id" json:"client_id,omitempty"`
	IpAddress        *IPAddress `protobuf:"bytes,2,opt,name=ip_address" json:"ip_address,omitempty"`
	Name             *string    `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *DhcpV6_Host) Reset()                    { *m = DhcpV6_Host{} }
func (m *DhcpV6_Host) String() string            { return proto.CompactTextString(m) }
func (*DhcpV6_Host) ProtoMessage()               {}
func (*DhcpV6_Host) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{4, 0} }

func (m *DhcpV6_Host) GetClientId() string {
	if m != nil && m.ClientId != nil {
		return *m.ClientId
	}
	return ""
}

func (m *DhcpV6_Host) GetIpAddress() *IPAddress {
	if m != nil {
		return m.IpAddress
	}
	return nil
}

func (m *DhcpV6_Host) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

type HealthMonitor struct {
	Id           *UUID                            `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	AdminStateUp *bool                            `protobuf:"varint,2,opt,name=admin_state_up" json:"admin_state_up,omitempty"`
	Type         *HealthMonitor_HealthMonitorType `protobuf:"varint,3,opt,name=type,enum=org.midonet.cluster.models.HealthMonitor_HealthMonitorType,def=1" json:"type,omitempty"`
	Status       *LBStatus                        `protobuf:"varint,4,opt,name=status,enum=org.midonet.cluster.models.LBStatus,def=1" json:"status,omitempty"`
	Delay        *int32                           `protobuf:"varint,5,opt,name=delay" json:"delay,omitempty"`
	Timeout      *int32                           `protobuf:"varint,6,opt,name=timeout" json:"timeout,omitempty"`
	MaxRetries   *int32                           `protobuf:"varint,7,opt,name=max_retries" json:"max_retries,omitempty"`
	// Backreferences
	PoolIds          []*UUID `protobuf:"bytes,101,rep,name=pool_ids" json:"pool_ids,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *HealthMonitor) Reset()                    { *m = HealthMonitor{} }
func (m *HealthMonitor) String() string            { return proto.CompactTextString(m) }
func (*HealthMonitor) ProtoMessage()               {}
func (*HealthMonitor) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{5} }

const Default_HealthMonitor_Type HealthMonitor_HealthMonitorType = HealthMonitor_TCP
const Default_HealthMonitor_Status LBStatus = LBStatus_ACTIVE

func (m *HealthMonitor) GetId() *UUID {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *HealthMonitor) GetAdminStateUp() bool {
	if m != nil && m.AdminStateUp != nil {
		return *m.AdminStateUp
	}
	return false
}

func (m *HealthMonitor) GetType() HealthMonitor_HealthMonitorType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Default_HealthMonitor_Type
}

func (m *HealthMonitor) GetStatus() LBStatus {
	if m != nil && m.Status != nil {
		return *m.Status
	}
	return Default_HealthMonitor_Status
}

func (m *HealthMonitor) GetDelay() int32 {
	if m != nil && m.Delay != nil {
		return *m.Delay
	}
	return 0
}

func (m *HealthMonitor) GetTimeout() int32 {
	if m != nil && m.Timeout != nil {
		return *m.Timeout
	}
	return 0
}

func (m *HealthMonitor) GetMaxRetries() int32 {
	if m != nil && m.MaxRetries != nil {
		return *m.MaxRetries
	}
	return 0
}

func (m *HealthMonitor) GetPoolIds() []*UUID {
	if m != nil {
		return m.PoolIds
	}
	return nil
}

type Host struct {
	Id                  *UUID   `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Name                *string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	FloodingProxyWeight *int32  `protobuf:"varint,3,opt,name=flooding_proxy_weight,def=1" json:"flooding_proxy_weight,omitempty"`
	// Backreference. Expected to be set from the Tunnel Zone side.
	TunnelZoneIds []*UUID `protobuf:"bytes,101,rep,name=tunnel_zone_ids" json:"tunnel_zone_ids,omitempty"`
	// Backreference. Expected to be set from the Port side.
	PortIds          []*UUID `protobuf:"bytes,102,rep,name=port_ids" json:"port_ids,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Host) Reset()                    { *m = Host{} }
func (m *Host) String() string            { return proto.CompactTextString(m) }
func (*Host) ProtoMessage()               {}
func (*Host) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{6} }

const Default_Host_FloodingProxyWeight int32 = 1

func (m *Host) GetId() *UUID {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *Host) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Host) GetFloodingProxyWeight() int32 {
	if m != nil && m.FloodingProxyWeight != nil {
		return *m.FloodingProxyWeight
	}
	return Default_Host_FloodingProxyWeight
}

func (m *Host) GetTunnelZoneIds() []*UUID {
	if m != nil {
		return m.TunnelZoneIds
	}
	return nil
}

func (m *Host) GetPortIds() []*UUID {
	if m != nil {
		return m.PortIds
	}
	return nil
}

type IPAddrGroup struct {
	Id              *UUID                      `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Name            *string                    `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	IpAddrPorts     []*IPAddrGroup_IPAddrPorts `protobuf:"bytes,3,rep,name=ip_addr_ports" json:"ip_addr_ports,omitempty"`
	InboundChainId  *UUID                      `protobuf:"bytes,4,opt,name=inbound_chain_id" json:"inbound_chain_id,omitempty"`
	OutboundChainId *UUID                      `protobuf:"bytes,5,opt,name=outbound_chain_id" json:"outbound_chain_id,omitempty"`
	// Backreferences
	RuleIds          []*UUID `protobuf:"bytes,6,rep,name=rule_ids" json:"rule_ids,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *IPAddrGroup) Reset()                    { *m = IPAddrGroup{} }
func (m *IPAddrGroup) String() string            { return proto.CompactTextString(m) }
func (*IPAddrGroup) ProtoMessage()               {}
func (*IPAddrGroup) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{7} }

func (m *IPAddrGroup) GetId() *UUID {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *IPAddrGroup) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *IPAddrGroup) GetIpAddrPorts() []*IPAddrGroup_IPAddrPorts {
	if m != nil {
		return m.IpAddrPorts
	}
	return nil
}

func (m *IPAddrGroup) GetInboundChainId() *UUID {
	if m != nil {
		return m.InboundChainId
	}
	return nil
}

func (m *IPAddrGroup) GetOutboundChainId() *UUID {
	if m != nil {
		return m.OutboundChainId
	}
	return nil
}

func (m *IPAddrGroup) GetRuleIds() []*UUID {
	if m != nil {
		return m.RuleIds
	}
	return nil
}

type IPAddrGroup_IPAddrPorts struct {
	IpAddress        *IPAddress `protobuf:"bytes,1,opt,name=ip_address" json:"ip_address,omitempty"`
	PortIds          []*UUID    `protobuf:"bytes,2,rep,name=port_ids" json:"port_ids,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *IPAddrGroup_IPAddrPorts) Reset()                    { *m = IPAddrGroup_IPAddrPorts{} }
func (m *IPAddrGroup_IPAddrPorts) String() string            { return proto.CompactTextString(m) }
func (*IPAddrGroup_IPAddrPorts) ProtoMessage()               {}
func (*IPAddrGroup_IPAddrPorts) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{7, 0} }

func (m *IPAddrGroup_IPAddrPorts) GetIpAddress() *IPAddress {
	if m != nil {
		return m.IpAddress
	}
	return nil
}

func (m *IPAddrGroup_IPAddrPorts) GetPortIds() []*UUID {
	if m != nil {
		return m.PortIds
	}
	return nil
}

type L2Insertion struct {
	Id        *UUID   `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	PortId    *UUID   `protobuf:"bytes,2,opt,name=port_id" json:"port_id,omitempty"`
	SrvPortId *UUID   `protobuf:"bytes,3,opt,name=srv_port_id" json:"srv_port_id,omitempty"`
	Vlan      *uint32 `protobuf:"varint,4,opt,name=vlan" json:"vlan,omitempty"`
	FailOpen  *bool   `protobuf:"varint,5,opt,name=fail_open" json:"fail_open,omitempty"`
	Position  *uint32 `protobuf:"varint,6,opt,name=position" json:"position,omitempty"`
	Mac       *string `protobuf:"bytes,7,opt,name=mac" json:"mac,omitempty"`
	// Keep a reference to the corresponding service port rule
	SrvRuleInId      *UUID  `protobuf:"bytes,100,opt,name=srv_rule_in_id" json:"srv_rule_in_id,omitempty"`
	SrvRuleOutId     *UUID  `protobuf:"bytes,101,opt,name=srv_rule_out_id" json:"srv_rule_out_id,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *L2Insertion) Reset()                    { *m = L2Insertion{} }
func (m *L2Insertion) String() string            { return proto.CompactTextString(m) }
func (*L2Insertion) ProtoMessage()               {}
func (*L2Insertion) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{8} }

func (m *L2Insertion) GetId() *UUID {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *L2Insertion) GetPortId() *UUID {
	if m != nil {
		return m.PortId
	}
	return nil
}

func (m *L2Insertion) GetSrvPortId() *UUID {
	if m != nil {
		return m.SrvPortId
	}
	return nil
}

func (m *L2Insertion) GetVlan() uint32 {
	if m != nil && m.Vlan != nil {
		return *m.Vlan
	}
	return 0
}

func (m *L2Insertion) GetFailOpen() bool {
	if m != nil && m.FailOpen != nil {
		return *m.FailOpen
	}
	return false
}

func (m *L2Insertion) GetPosition() uint32 {
	if m != nil && m.Position != nil {
		return *m.Position
	}
	return 0
}

func (m *L2Insertion) GetMac() string {
	if m != nil && m.Mac != nil {
		return *m.Mac
	}
	return ""
}

func (m *L2Insertion) GetSrvRuleInId() *UUID {
	if m != nil {
		return m.SrvRuleInId
	}
	return nil
}

func (m *L2Insertion) GetSrvRuleOutId() *UUID {
	if m != nil {
		return m.SrvRuleOutId
	}
	return nil
}

type LoadBalancer struct {
	// Load Balancer ID is always the same as the Router ID to which the LB is
	// attached. Therefore, LoadBalancer does not have a reference to Router.
	Id           *UUID `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	AdminStateUp *bool `protobuf:"varint,2,opt,name=admin_state_up" json:"admin_state_up,omitempty"`
	// Backreference
	RouterId         *UUID   `protobuf:"bytes,101,opt,name=router_id" json:"router_id,omitempty"`
	PoolIds          []*UUID `protobuf:"bytes,102,rep,name=pool_ids" json:"pool_ids,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *LoadBalancer) Reset()                    { *m = LoadBalancer{} }
func (m *LoadBalancer) String() string            { return proto.CompactTextString(m) }
func (*LoadBalancer) ProtoMessage()               {}
func (*LoadBalancer) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{9} }

func (m *LoadBalancer) GetId() *UUID {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *LoadBalancer) GetAdminStateUp() bool {
	if m != nil && m.AdminStateUp != nil {
		return *m.AdminStateUp
	}
	return false
}

func (m *LoadBalancer) GetRouterId() *UUID {
	if m != nil {
		return m.RouterId
	}
	return nil
}

func (m *LoadBalancer) GetPoolIds() []*UUID {
	if m != nil {
		return m.PoolIds
	}
	return nil
}

type Mirror struct {
	Id         *UUID        `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	ToPortId   *UUID        `protobuf:"bytes,2,opt,name=to_port_id" json:"to_port_id,omitempty"`
	Conditions []*Condition `protobuf:"bytes,3,rep,name=conditions" json:"conditions,omitempty"`
	// Backreferences
	NetworkInboundIds  []*UUID `protobuf:"bytes,101,rep,name=network_inbound_ids" json:"network_inbound_ids,omitempty"`
	NetworkOutboundIds []*UUID `protobuf:"bytes,102,rep,name=network_outbound_ids" json:"network_outbound_ids,omitempty"`
	RouterInboundIds   []*UUID `protobuf:"bytes,103,rep,name=router_inbound_ids" json:"router_inbound_ids,omitempty"`
	RouterOutboundIds  []*UUID `protobuf:"bytes,104,rep,name=router_outbound_ids" json:"router_outbound_ids,omitempty"`
	PortInboundIds     []*UUID `protobuf:"bytes,105,rep,name=port_inbound_ids" json:"port_inbound_ids,omitempty"`
	PortOutboundIds    []*UUID `protobuf:"bytes,106,rep,name=port_outbound_ids" json:"port_outbound_ids,omitempty"`
	XXX_unrecognized   []byte  `json:"-"`
}

func (m *Mirror) Reset()                    { *m = Mirror{} }
func (m *Mirror) String() string            { return proto.CompactTextString(m) }
func (*Mirror) ProtoMessage()               {}
func (*Mirror) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{10} }

func (m *Mirror) GetId() *UUID {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *Mirror) GetToPortId() *UUID {
	if m != nil {
		return m.ToPortId
	}
	return nil
}

func (m *Mirror) GetConditions() []*Condition {
	if m != nil {
		return m.Conditions
	}
	return nil
}

func (m *Mirror) GetNetworkInboundIds() []*UUID {
	if m != nil {
		return m.NetworkInboundIds
	}
	return nil
}

func (m *Mirror) GetNetworkOutboundIds() []*UUID {
	if m != nil {
		return m.NetworkOutboundIds
	}
	return nil
}

func (m *Mirror) GetRouterInboundIds() []*UUID {
	if m != nil {
		return m.RouterInboundIds
	}
	return nil
}

func (m *Mirror) GetRouterOutboundIds() []*UUID {
	if m != nil {
		return m.RouterOutboundIds
	}
	return nil
}

func (m *Mirror) GetPortInboundIds() []*UUID {
	if m != nil {
		return m.PortInboundIds
	}
	return nil
}

func (m *Mirror) GetPortOutboundIds() []*UUID {
	if m != nil {
		return m.PortOutboundIds
	}
	return nil
}

type Network struct {
	// Neutron / MidoNet common attributes
	Id           *UUID   `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	TenantId     *string `protobuf:"bytes,2,opt,name=tenant_id" json:"tenant_id,omitempty"`
	Name         *string `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
	AdminStateUp *bool   `protobuf:"varint,4,opt,name=admin_state_up" json:"admin_state_up,omitempty"`
	// MidoNet-specific fields
	TunnelKey        *uint64 `protobuf:"varint,5,opt,name=tunnel_key" json:"tunnel_key,omitempty"`
	InboundFilterId  *UUID   `protobuf:"bytes,6,opt,name=inbound_filter_id" json:"inbound_filter_id,omitempty"`
	OutboundFilterId *UUID   `protobuf:"bytes,7,opt,name=outbound_filter_id" json:"outbound_filter_id,omitempty"`
	// If the Network is bound to any VTEPs, it'll be assigned a VNI
	// that is used for all bindings to all VTEPs
	Vni               *uint32 `protobuf:"varint,8,opt,name=vni" json:"vni,omitempty"`
	InboundMirrorIds  []*UUID `protobuf:"bytes,9,rep,name=inbound_mirror_ids" json:"inbound_mirror_ids,omitempty"`
	OutboundMirrorIds []*UUID `protobuf:"bytes,10,rep,name=outbound_mirror_ids" json:"outbound_mirror_ids,omitempty"`
	// Backreferences
	PortIds          []*UUID `protobuf:"bytes,101,rep,name=port_ids" json:"port_ids,omitempty"`
	VxlanPortIds     []*UUID `protobuf:"bytes,102,rep,name=vxlan_port_ids" json:"vxlan_port_ids,omitempty"`
	DhcpIds          []*UUID `protobuf:"bytes,103,rep,name=dhcp_ids" json:"dhcp_ids,omitempty"`
	Dhcpv6Ids        []*UUID `protobuf:"bytes,104,rep,name=dhcpv6_ids" json:"dhcpv6_ids,omitempty"`
	TraceRequestIds  []*UUID `protobuf:"bytes,105,rep,name=trace_request_ids" json:"trace_request_ids,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Network) Reset()                    { *m = Network{} }
func (m *Network) String() string            { return proto.CompactTextString(m) }
func (*Network) ProtoMessage()               {}
func (*Network) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{11} }

func (m *Network) GetId() *UUID {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *Network) GetTenantId() string {
	if m != nil && m.TenantId != nil {
		return *m.TenantId
	}
	return ""
}

func (m *Network) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Network) GetAdminStateUp() bool {
	if m != nil && m.AdminStateUp != nil {
		return *m.AdminStateUp
	}
	return false
}

func (m *Network) GetTunnelKey() uint64 {
	if m != nil && m.TunnelKey != nil {
		return *m.TunnelKey
	}
	return 0
}

func (m *Network) GetInboundFilterId() *UUID {
	if m != nil {
		return m.InboundFilterId
	}
	return nil
}

func (m *Network) GetOutboundFilterId() *UUID {
	if m != nil {
		return m.OutboundFilterId
	}
	return nil
}

func (m *Network) GetVni() uint32 {
	if m != nil && m.Vni != nil {
		return *m.Vni
	}
	return 0
}

func (m *Network) GetInboundMirrorIds() []*UUID {
	if m != nil {
		return m.InboundMirrorIds
	}
	return nil
}

func (m *Network) GetOutboundMirrorIds() []*UUID {
	if m != nil {
		return m.OutboundMirrorIds
	}
	return nil
}

func (m *Network) GetPortIds() []*UUID {
	if m != nil {
		return m.PortIds
	}
	return nil
}

func (m *Network) GetVxlanPortIds() []*UUID {
	if m != nil {
		return m.VxlanPortIds
	}
	return nil
}

func (m *Network) GetDhcpIds() []*UUID {
	if m != nil {
		return m.DhcpIds
	}
	return nil
}

func (m *Network) GetDhcpv6Ids() []*UUID {
	if m != nil {
		return m.Dhcpv6Ids
	}
	return nil
}

func (m *Network) GetTraceRequestIds() []*UUID {
	if m != nil {
		return m.TraceRequestIds
	}
	return nil
}

type Pool struct {
	Id              *UUID `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	HealthMonitorId *UUID `protobuf:"bytes,2,opt,name=health_monitor_id" json:"health_monitor_id,omitempty"`
	// load_balancer_id is always the same as the corresponding Router ID.
	LoadBalancerId *UUID                                `protobuf:"bytes,3,opt,name=load_balancer_id" json:"load_balancer_id,omitempty"`
	AdminStateUp   *bool                                `protobuf:"varint,4,opt,name=admin_state_up" json:"admin_state_up,omitempty"`
	Protocol       *Pool_PoolProtocol                   `protobuf:"varint,5,opt,name=protocol,enum=org.midonet.cluster.models.Pool_PoolProtocol,def=1" json:"protocol,omitempty"`
	LbMethod       *Pool_PoolLBMethod                   `protobuf:"varint,6,opt,name=lb_method,enum=org.midonet.cluster.models.Pool_PoolLBMethod,def=1" json:"lb_method,omitempty"`
	Status         *LBStatus                            `protobuf:"varint,7,opt,name=status,enum=org.midonet.cluster.models.LBStatus,def=1" json:"status,omitempty"`
	MappingStatus  *Pool_PoolHealthMonitorMappingStatus `protobuf:"varint,8,opt,name=mapping_status,enum=org.midonet.cluster.models.Pool_PoolHealthMonitorMappingStatus" json:"mapping_status,omitempty"`
	// Backreferences
	PoolMemberIds    []*UUID `protobuf:"bytes,101,rep,name=pool_member_ids" json:"pool_member_ids,omitempty"`
	VipIds           []*UUID `protobuf:"bytes,102,rep,name=vip_ids" json:"vip_ids,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Pool) Reset()                    { *m = Pool{} }
func (m *Pool) String() string            { return proto.CompactTextString(m) }
func (*Pool) ProtoMessage()               {}
func (*Pool) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{12} }

const Default_Pool_Protocol Pool_PoolProtocol = Pool_TCP
const Default_Pool_LbMethod Pool_PoolLBMethod = Pool_ROUND_ROBIN
const Default_Pool_Status LBStatus = LBStatus_ACTIVE

func (m *Pool) GetId() *UUID {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *Pool) GetHealthMonitorId() *UUID {
	if m != nil {
		return m.HealthMonitorId
	}
	return nil
}

func (m *Pool) GetLoadBalancerId() *UUID {
	if m != nil {
		return m.LoadBalancerId
	}
	return nil
}

func (m *Pool) GetAdminStateUp() bool {
	if m != nil && m.AdminStateUp != nil {
		return *m.AdminStateUp
	}
	return false
}

func (m *Pool) GetProtocol() Pool_PoolProtocol {
	if m != nil && m.Protocol != nil {
		return *m.Protocol
	}
	return Default_Pool_Protocol
}

func (m *Pool) GetLbMethod() Pool_PoolLBMethod {
	if m != nil && m.LbMethod != nil {
		return *m.LbMethod
	}
	return Default_Pool_LbMethod
}

func (m *Pool) GetStatus() LBStatus {
	if m != nil && m.Status != nil {
		return *m.Status
	}
	return Default_Pool_Status
}

func (m *Pool) GetMappingStatus() Pool_PoolHealthMonitorMappingStatus {
	if m != nil && m.MappingStatus != nil {
		return *m.MappingStatus
	}
	return Pool_ACTIVE
}

func (m *Pool) GetPoolMemberIds() []*UUID {
	if m != nil {
		return m.PoolMemberIds
	}
	return nil
}

func (m *Pool) GetVipIds() []*UUID {
	if m != nil {
		return m.VipIds
	}
	return nil
}

type PoolMember struct {
	Id               *UUID      `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	AdminStateUp     *bool      `protobuf:"varint,2,opt,name=admin_state_up" json:"admin_state_up,omitempty"`
	PoolId           *UUID      `protobuf:"bytes,3,opt,name=pool_id" json:"pool_id,omitempty"`
	Status           *LBStatus  `protobuf:"varint,4,opt,name=status,enum=org.midonet.cluster.models.LBStatus,def=1" json:"status,omitempty"`
	Address          *IPAddress `protobuf:"bytes,5,opt,name=address" json:"address,omitempty"`
	ProtocolPort     *int32     `protobuf:"varint,6,opt,name=protocol_port" json:"protocol_port,omitempty"`
	Weight           *int32     `protobuf:"varint,7,opt,name=weight" json:"weight,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *PoolMember) Reset()                    { *m = PoolMember{} }
func (m *PoolMember) String() string            { return proto.CompactTextString(m) }
func (*PoolMember) ProtoMessage()               {}
func (*PoolMember) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{13} }

const Default_PoolMember_Status LBStatus = LBStatus_ACTIVE

func (m *PoolMember) GetId() *UUID {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *PoolMember) GetAdminStateUp() bool {
	if m != nil && m.AdminStateUp != nil {
		return *m.AdminStateUp
	}
	return false
}

func (m *PoolMember) GetPoolId() *UUID {
	if m != nil {
		return m.PoolId
	}
	return nil
}

func (m *PoolMember) GetStatus() LBStatus {
	if m != nil && m.Status != nil {
		return *m.Status
	}
	return Default_PoolMember_Status
}

func (m *PoolMember) GetAddress() *IPAddress {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *PoolMember) GetProtocolPort() int32 {
	if m != nil && m.ProtocolPort != nil {
		return *m.ProtocolPort
	}
	return 0
}

func (m *PoolMember) GetWeight() int32 {
	if m != nil && m.Weight != nil {
		return *m.Weight
	}
	return 0
}

type Port struct {
	Id               *UUID   `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	NetworkId        *UUID   `protobuf:"bytes,2,opt,name=network_id" json:"network_id,omitempty"`
	RouterId         *UUID   `protobuf:"bytes,3,opt,name=router_id" json:"router_id,omitempty"`
	InboundFilterId  *UUID   `protobuf:"bytes,4,opt,name=inbound_filter_id" json:"inbound_filter_id,omitempty"`
	OutboundFilterId *UUID   `protobuf:"bytes,5,opt,name=outbound_filter_id" json:"outbound_filter_id,omitempty"`
	TunnelKey        *uint64 `protobuf:"varint,6,opt,name=tunnel_key" json:"tunnel_key,omitempty"`
	PeerId           *UUID   `protobuf:"bytes,7,opt,name=peer_id" json:"peer_id,omitempty"`
	VifId            *UUID   `protobuf:"bytes,8,opt,name=vif_id" json:"vif_id,omitempty"`
	HostId           *UUID   `protobuf:"bytes,9,opt,name=host_id" json:"host_id,omitempty"`
	InterfaceName    *string `protobuf:"bytes,10,opt,name=interface_name" json:"interface_name,omitempty"`
	AdminStateUp     *bool   `protobuf:"varint,11,opt,name=admin_state_up,def=1" json:"admin_state_up,omitempty"`
	PortGroupIds     []*UUID `protobuf:"bytes,12,rep,name=port_group_ids" json:"port_group_ids,omitempty"`
	// Interior bridge port specific
	VlanId *uint32 `protobuf:"varint,13,opt,name=vlan_id" json:"vlan_id,omitempty"`
	// Router port specific
	PortSubnet  *IPSubnet  `protobuf:"bytes,14,opt,name=port_subnet" json:"port_subnet,omitempty"`
	PortAddress *IPAddress `protobuf:"bytes,15,opt,name=port_address" json:"port_address,omitempty"`
	PortMac     *string    `protobuf:"bytes,16,opt,name=port_mac" json:"port_mac,omitempty"`
	RouteIds    []*UUID    `protobuf:"bytes,17,rep,name=route_ids" json:"route_ids,omitempty"`
	// Specific to router interface ports (not used for router gateway ports).
	DhcpId *UUID `protobuf:"bytes,18,opt,name=dhcp_id" json:"dhcp_id,omitempty"`
	// VXLAN port specific
	VtepId *UUID `protobuf:"bytes,19,opt,name=vtep_id" json:"vtep_id,omitempty"`
	// mirroring
	InboundMirrorIds  []*UUID `protobuf:"bytes,20,rep,name=inbound_mirror_ids" json:"inbound_mirror_ids,omitempty"`
	OutboundMirrorIds []*UUID `protobuf:"bytes,21,rep,name=outbound_mirror_ids" json:"outbound_mirror_ids,omitempty"`
	// l2 insertion filters (should only be set by translation)
	L2InsertionInfilterId  *UUID `protobuf:"bytes,23,opt,name=l2insertion_infilter_id" json:"l2insertion_infilter_id,omitempty"`
	L2InsertionOutfilterId *UUID `protobuf:"bytes,24,opt,name=l2insertion_outfilter_id" json:"l2insertion_outfilter_id,omitempty"`
	// For Router gateway port only. Back-references to VIPs that are associated
	// with this Router gateway port.
	VipIds []*UUID `protobuf:"bytes,101,rep,name=vip_ids" json:"vip_ids,omitempty"`
	// NAT rules that implement FIP for this port.
	FipNatRuleIds   []*UUID `protobuf:"bytes,102,rep,name=fip_nat_rule_ids" json:"fip_nat_rule_ids,omitempty"`
	TraceRequestIds []*UUID `protobuf:"bytes,103,rep,name=trace_request_ids" json:"trace_request_ids,omitempty"`
	// Mirrors that forward to this port
	MirrorIds []*UUID `protobuf:"bytes,104,rep,name=mirror_ids" json:"mirror_ids,omitempty"`
	// service insertion
	InsertionIds     []*UUID `protobuf:"bytes,110,rep,name=insertion_ids" json:"insertion_ids,omitempty"`
	SrvInsertionIds  []*UUID `protobuf:"bytes,111,rep,name=srv_insertion_ids" json:"srv_insertion_ids,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Port) Reset()                    { *m = Port{} }
func (m *Port) String() string            { return proto.CompactTextString(m) }
func (*Port) ProtoMessage()               {}
func (*Port) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{14} }

const Default_Port_AdminStateUp bool = true

func (m *Port) GetId() *UUID {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *Port) GetNetworkId() *UUID {
	if m != nil {
		return m.NetworkId
	}
	return nil
}

func (m *Port) GetRouterId() *UUID {
	if m != nil {
		return m.RouterId
	}
	return nil
}

func (m *Port) GetInboundFilterId() *UUID {
	if m != nil {
		return m.InboundFilterId
	}
	return nil
}

func (m *Port) GetOutboundFilterId() *UUID {
	if m != nil {
		return m.OutboundFilterId
	}
	return nil
}

func (m *Port) GetTunnelKey() uint64 {
	if m != nil && m.TunnelKey != nil {
		return *m.TunnelKey
	}
	return 0
}

func (m *Port) GetPeerId() *UUID {
	if m != nil {
		return m.PeerId
	}
	return nil
}

func (m *Port) GetVifId() *UUID {
	if m != nil {
		return m.VifId
	}
	return nil
}

func (m *Port) GetHostId() *UUID {
	if m != nil {
		return m.HostId
	}
	return nil
}

func (m *Port) GetInterfaceName() string {
	if m != nil && m.InterfaceName != nil {
		return *m.InterfaceName
	}
	return ""
}

func (m *Port) GetAdminStateUp() bool {
	if m != nil && m.AdminStateUp != nil {
		return *m.AdminStateUp
	}
	return Default_Port_AdminStateUp
}

func (m *Port) GetPortGroupIds() []*UUID {
	if m != nil {
		return m.PortGroupIds
	}
	return nil
}

func (m *Port) GetVlanId() uint32 {
	if m != nil && m.VlanId != nil {
		return *m.VlanId
	}
	return 0
}

func (m *Port) GetPortSubnet() *IPSubnet {
	if m != nil {
		return m.PortSubnet
	}
	return nil
}

func (m *Port) GetPortAddress() *IPAddress {
	if m != nil {
		return m.PortAddress
	}
	return nil
}

func (m *Port) GetPortMac() string {
	if m != nil && m.PortMac != nil {
		return *m.PortMac
	}
	return ""
}

func (m *Port) GetRouteIds() []*UUID {
	if m != nil {
		return m.RouteIds
	}
	return nil
}

func (m *Port) GetDhcpId() *UUID {
	if m != nil {
		return m.DhcpId
	}
	return nil
}

func (m *Port) GetVtepId() *UUID {
	if m != nil {
		return m.VtepId
	}
	return nil
}

func (m *Port) GetInboundMirrorIds() []*UUID {
	if m != nil {
		return m.InboundMirrorIds
	}
	return nil
}

func (m *Port) GetOutboundMirrorIds() []*UUID {
	if m != nil {
		return m.OutboundMirrorIds
	}
	return nil
}

func (m *Port) GetL2InsertionInfilterId() *UUID {
	if m != nil {
		return m.L2InsertionInfilterId
	}
	return nil
}

func (m *Port) GetL2InsertionOutfilterId() *UUID {
	if m != nil {
		return m.L2InsertionOutfilterId
	}
	return nil
}

func (m *Port) GetVipIds() []*UUID {
	if m != nil {
		return m.VipIds
	}
	return nil
}

func (m *Port) GetFipNatRuleIds() []*UUID {
	if m != nil {
		return m.FipNatRuleIds
	}
	return nil
}

func (m *Port) GetTraceRequestIds() []*UUID {
	if m != nil {
		return m.TraceRequestIds
	}
	return nil
}

func (m *Port) GetMirrorIds() []*UUID {
	if m != nil {
		return m.MirrorIds
	}
	return nil
}

func (m *Port) GetInsertionIds() []*UUID {
	if m != nil {
		return m.InsertionIds
	}
	return nil
}

func (m *Port) GetSrvInsertionIds() []*UUID {
	if m != nil {
		return m.SrvInsertionIds
	}
	return nil
}

type PortGroup struct {
	Id       *UUID   `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Name     *string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	TenantId *string `protobuf:"bytes,3,opt,name=tenant_id" json:"tenant_id,omitempty"`
	Stateful *bool   `protobuf:"varint,4,opt,name=stateful" json:"stateful,omitempty"`
	// Backreferences
	PortIds          []*UUID `protobuf:"bytes,101,rep,name=port_ids" json:"port_ids,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *PortGroup) Reset()                    { *m = PortGroup{} }
func (m *PortGroup) String() string            { return proto.CompactTextString(m) }
func (*PortGroup) ProtoMessage()               {}
func (*PortGroup) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{15} }

func (m *PortGroup) GetId() *UUID {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *PortGroup) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *PortGroup) GetTenantId() string {
	if m != nil && m.TenantId != nil {
		return *m.TenantId
	}
	return ""
}

func (m *PortGroup) GetStateful() bool {
	if m != nil && m.Stateful != nil {
		return *m.Stateful
	}
	return false
}

func (m *PortGroup) GetPortIds() []*UUID {
	if m != nil {
		return m.PortIds
	}
	return nil
}

type Route struct {
	Id               *UUID          `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	SrcSubnet        *IPSubnet      `protobuf:"bytes,2,opt,name=src_subnet" json:"src_subnet,omitempty"`
	DstSubnet        *IPSubnet      `protobuf:"bytes,3,opt,name=dst_subnet" json:"dst_subnet,omitempty"`
	NextHop          *Route_NextHop `protobuf:"varint,4,opt,name=next_hop,enum=org.midonet.cluster.models.Route_NextHop" json:"next_hop,omitempty"`
	NextHopPortId    *UUID          `protobuf:"bytes,5,opt,name=next_hop_port_id" json:"next_hop_port_id,omitempty"`
	Weight           *int32         `protobuf:"varint,6,opt,name=weight" json:"weight,omitempty"`
	Attributes       *string        `protobuf:"bytes,7,opt,name=attributes" json:"attributes,omitempty"`
	RouterId         *UUID          `protobuf:"bytes,8,opt,name=router_id" json:"router_id,omitempty"`
	NextHopGateway   *IPAddress     `protobuf:"bytes,9,opt,name=next_hop_gateway" json:"next_hop_gateway,omitempty"`
	GatewayDhcpId    *UUID          `protobuf:"bytes,10,opt,name=gateway_dhcp_id" json:"gateway_dhcp_id,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *Route) Reset()                    { *m = Route{} }
func (m *Route) String() string            { return proto.CompactTextString(m) }
func (*Route) ProtoMessage()               {}
func (*Route) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{16} }

func (m *Route) GetId() *UUID {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *Route) GetSrcSubnet() *IPSubnet {
	if m != nil {
		return m.SrcSubnet
	}
	return nil
}

func (m *Route) GetDstSubnet() *IPSubnet {
	if m != nil {
		return m.DstSubnet
	}
	return nil
}

func (m *Route) GetNextHop() Route_NextHop {
	if m != nil && m.NextHop != nil {
		return *m.NextHop
	}
	return Route_BLACKHOLE
}

func (m *Route) GetNextHopPortId() *UUID {
	if m != nil {
		return m.NextHopPortId
	}
	return nil
}

func (m *Route) GetWeight() int32 {
	if m != nil && m.Weight != nil {
		return *m.Weight
	}
	return 0
}

func (m *Route) GetAttributes() string {
	if m != nil && m.Attributes != nil {
		return *m.Attributes
	}
	return ""
}

func (m *Route) GetRouterId() *UUID {
	if m != nil {
		return m.RouterId
	}
	return nil
}

func (m *Route) GetNextHopGateway() *IPAddress {
	if m != nil {
		return m.NextHopGateway
	}
	return nil
}

func (m *Route) GetGatewayDhcpId() *UUID {
	if m != nil {
		return m.GatewayDhcpId
	}
	return nil
}

type Router struct {
	Id               *UUID   `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	TenantId         *string `protobuf:"bytes,2,opt,name=tenant_id" json:"tenant_id,omitempty"`
	Name             *string `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
	AdminStateUp     *bool   `protobuf:"varint,4,opt,name=admin_state_up" json:"admin_state_up,omitempty"`
	InboundFilterId  *UUID   `protobuf:"bytes,5,opt,name=inbound_filter_id" json:"inbound_filter_id,omitempty"`
	OutboundFilterId *UUID   `protobuf:"bytes,6,opt,name=outbound_filter_id" json:"outbound_filter_id,omitempty"`
	LoadBalancerId   *UUID   `protobuf:"bytes,7,opt,name=load_balancer_id" json:"load_balancer_id,omitempty"`
	RouteIds         []*UUID `protobuf:"bytes,8,rep,name=route_ids" json:"route_ids,omitempty"`
	// Specific to routers that have BGP routing enabled.
	AsNumber      *int32  `protobuf:"varint,9,opt,name=as_number,def=-1" json:"as_number,omitempty"`
	BgpNetworkIds []*UUID `protobuf:"bytes,10,rep,name=bgp_network_ids" json:"bgp_network_ids,omitempty"`
	BgpPeerIds    []*UUID `protobuf:"bytes,11,rep,name=bgp_peer_ids" json:"bgp_peer_ids,omitempty"`
	// Mirroring
	InboundMirrorIds  []*UUID `protobuf:"bytes,12,rep,name=inbound_mirror_ids" json:"inbound_mirror_ids,omitempty"`
	OutboundMirrorIds []*UUID `protobuf:"bytes,13,rep,name=outbound_mirror_ids" json:"outbound_mirror_ids,omitempty"`
	// Backreferences
	PortIds          []*UUID `protobuf:"bytes,101,rep,name=port_ids" json:"port_ids,omitempty"`
	TraceRequestIds  []*UUID `protobuf:"bytes,102,rep,name=trace_request_ids" json:"trace_request_ids,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Router) Reset()                    { *m = Router{} }
func (m *Router) String() string            { return proto.CompactTextString(m) }
func (*Router) ProtoMessage()               {}
func (*Router) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{17} }

const Default_Router_AsNumber int32 = -1

func (m *Router) GetId() *UUID {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *Router) GetTenantId() string {
	if m != nil && m.TenantId != nil {
		return *m.TenantId
	}
	return ""
}

func (m *Router) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Router) GetAdminStateUp() bool {
	if m != nil && m.AdminStateUp != nil {
		return *m.AdminStateUp
	}
	return false
}

func (m *Router) GetInboundFilterId() *UUID {
	if m != nil {
		return m.InboundFilterId
	}
	return nil
}

func (m *Router) GetOutboundFilterId() *UUID {
	if m != nil {
		return m.OutboundFilterId
	}
	return nil
}

func (m *Router) GetLoadBalancerId() *UUID {
	if m != nil {
		return m.LoadBalancerId
	}
	return nil
}

func (m *Router) GetRouteIds() []*UUID {
	if m != nil {
		return m.RouteIds
	}
	return nil
}

func (m *Router) GetAsNumber() int32 {
	if m != nil && m.AsNumber != nil {
		return *m.AsNumber
	}
	return Default_Router_AsNumber
}

func (m *Router) GetBgpNetworkIds() []*UUID {
	if m != nil {
		return m.BgpNetworkIds
	}
	return nil
}

func (m *Router) GetBgpPeerIds() []*UUID {
	if m != nil {
		return m.BgpPeerIds
	}
	return nil
}

func (m *Router) GetInboundMirrorIds() []*UUID {
	if m != nil {
		return m.InboundMirrorIds
	}
	return nil
}

func (m *Router) GetOutboundMirrorIds() []*UUID {
	if m != nil {
		return m.OutboundMirrorIds
	}
	return nil
}

func (m *Router) GetPortIds() []*UUID {
	if m != nil {
		return m.PortIds
	}
	return nil
}

func (m *Router) GetTraceRequestIds() []*UUID {
	if m != nil {
		return m.TraceRequestIds
	}
	return nil
}

type Rule struct {
	Id        *UUID        `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Type      *Rule_Type   `protobuf:"varint,2,opt,name=type,enum=org.midonet.cluster.models.Rule_Type" json:"type,omitempty"`
	ChainId   *UUID        `protobuf:"bytes,3,opt,name=chain_id" json:"chain_id,omitempty"`
	Action    *Rule_Action `protobuf:"varint,4,opt,name=action,enum=org.midonet.cluster.models.Rule_Action" json:"action,omitempty"`
	Condition *Condition   `protobuf:"bytes,5,opt,name=condition" json:"condition,omitempty"`
	// Port for which this rule implements floating IP NAT.
	FipPortId *UUID `protobuf:"bytes,6,opt,name=fip_port_id" json:"fip_port_id,omitempty"`
	// Types that are valid to be assigned to RuleData:
	//	*Rule_JumpRuleData_
	//	*Rule_NatRuleData_
	//	*Rule_TraceRuleData_
	//	*Rule_TransformRuleData
	RuleData         isRule_RuleData `protobuf_oneof:"rule_data"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *Rule) Reset()                    { *m = Rule{} }
func (m *Rule) String() string            { return proto.CompactTextString(m) }
func (*Rule) ProtoMessage()               {}
func (*Rule) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{18} }

type isRule_RuleData interface {
	isRule_RuleData()
}

type Rule_JumpRuleData_ struct {
	JumpRuleData *Rule_JumpRuleData `protobuf:"bytes,100,opt,name=jump_rule_data,oneof"`
}
type Rule_NatRuleData_ struct {
	NatRuleData *Rule_NatRuleData `protobuf:"bytes,101,opt,name=nat_rule_data,oneof"`
}
type Rule_TraceRuleData_ struct {
	TraceRuleData *Rule_TraceRuleData `protobuf:"bytes,102,opt,name=trace_rule_data,oneof"`
}
type Rule_TransformRuleData struct {
	TransformRuleData *Rule_L2TransformRuleData `protobuf:"bytes,103,opt,name=transform_rule_data,oneof"`
}

func (*Rule_JumpRuleData_) isRule_RuleData()     {}
func (*Rule_NatRuleData_) isRule_RuleData()      {}
func (*Rule_TraceRuleData_) isRule_RuleData()    {}
func (*Rule_TransformRuleData) isRule_RuleData() {}

func (m *Rule) GetRuleData() isRule_RuleData {
	if m != nil {
		return m.RuleData
	}
	return nil
}

func (m *Rule) GetId() *UUID {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *Rule) GetType() Rule_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Rule_LITERAL_RULE
}

func (m *Rule) GetChainId() *UUID {
	if m != nil {
		return m.ChainId
	}
	return nil
}

func (m *Rule) GetAction() Rule_Action {
	if m != nil && m.Action != nil {
		return *m.Action
	}
	return Rule_ACCEPT
}

func (m *Rule) GetCondition() *Condition {
	if m != nil {
		return m.Condition
	}
	return nil
}

func (m *Rule) GetFipPortId() *UUID {
	if m != nil {
		return m.FipPortId
	}
	return nil
}

func (m *Rule) GetJumpRuleData() *Rule_JumpRuleData {
	if x, ok := m.GetRuleData().(*Rule_JumpRuleData_); ok {
		return x.JumpRuleData
	}
	return nil
}

func (m *Rule) GetNatRuleData() *Rule_NatRuleData {
	if x, ok := m.GetRuleData().(*Rule_NatRuleData_); ok {
		return x.NatRuleData
	}
	return nil
}

func (m *Rule) GetTraceRuleData() *Rule_TraceRuleData {
	if x, ok := m.GetRuleData().(*Rule_TraceRuleData_); ok {
		return x.TraceRuleData
	}
	return nil
}

func (m *Rule) GetTransformRuleData() *Rule_L2TransformRuleData {
	if x, ok := m.GetRuleData().(*Rule_TransformRuleData); ok {
		return x.TransformRuleData
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Rule) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), []interface{}) {
	return _Rule_OneofMarshaler, _Rule_OneofUnmarshaler, []interface{}{
		(*Rule_JumpRuleData_)(nil),
		(*Rule_NatRuleData_)(nil),
		(*Rule_TraceRuleData_)(nil),
		(*Rule_TransformRuleData)(nil),
	}
}

func _Rule_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Rule)
	// rule_data
	switch x := m.RuleData.(type) {
	case *Rule_JumpRuleData_:
		b.EncodeVarint(100<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.JumpRuleData); err != nil {
			return err
		}
	case *Rule_NatRuleData_:
		b.EncodeVarint(101<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NatRuleData); err != nil {
			return err
		}
	case *Rule_TraceRuleData_:
		b.EncodeVarint(102<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TraceRuleData); err != nil {
			return err
		}
	case *Rule_TransformRuleData:
		b.EncodeVarint(103<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TransformRuleData); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Rule.RuleData has unexpected type %T", x)
	}
	return nil
}

func _Rule_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Rule)
	switch tag {
	case 100: // rule_data.jump_rule_data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Rule_JumpRuleData)
		err := b.DecodeMessage(msg)
		m.RuleData = &Rule_JumpRuleData_{msg}
		return true, err
	case 101: // rule_data.nat_rule_data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Rule_NatRuleData)
		err := b.DecodeMessage(msg)
		m.RuleData = &Rule_NatRuleData_{msg}
		return true, err
	case 102: // rule_data.trace_rule_data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Rule_TraceRuleData)
		err := b.DecodeMessage(msg)
		m.RuleData = &Rule_TraceRuleData_{msg}
		return true, err
	case 103: // rule_data.transform_rule_data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Rule_L2TransformRuleData)
		err := b.DecodeMessage(msg)
		m.RuleData = &Rule_TransformRuleData{msg}
		return true, err
	default:
		return false, nil
	}
}

type Rule_JumpRuleData struct {
	JumpChainId      *UUID   `protobuf:"bytes,1,opt,name=jump_chain_id" json:"jump_chain_id,omitempty"`
	JumpChainName    *string `protobuf:"bytes,2,opt,name=jump_chain_name" json:"jump_chain_name,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Rule_JumpRuleData) Reset()                    { *m = Rule_JumpRuleData{} }
func (m *Rule_JumpRuleData) String() string            { return proto.CompactTextString(m) }
func (*Rule_JumpRuleData) ProtoMessage()               {}
func (*Rule_JumpRuleData) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{18, 0} }

func (m *Rule_JumpRuleData) GetJumpChainId() *UUID {
	if m != nil {
		return m.JumpChainId
	}
	return nil
}

func (m *Rule_JumpRuleData) GetJumpChainName() string {
	if m != nil && m.JumpChainName != nil {
		return *m.JumpChainName
	}
	return ""
}

type Rule_NatTarget struct {
	NwStart          *IPAddress `protobuf:"bytes,1,opt,name=nw_start" json:"nw_start,omitempty"`
	NwEnd            *IPAddress `protobuf:"bytes,2,opt,name=nw_end" json:"nw_end,omitempty"`
	TpStart          *uint32    `protobuf:"varint,3,opt,name=tp_start" json:"tp_start,omitempty"`
	TpEnd            *uint32    `protobuf:"varint,4,opt,name=tp_end" json:"tp_end,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *Rule_NatTarget) Reset()                    { *m = Rule_NatTarget{} }
func (m *Rule_NatTarget) String() string            { return proto.CompactTextString(m) }
func (*Rule_NatTarget) ProtoMessage()               {}
func (*Rule_NatTarget) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{18, 1} }

func (m *Rule_NatTarget) GetNwStart() *IPAddress {
	if m != nil {
		return m.NwStart
	}
	return nil
}

func (m *Rule_NatTarget) GetNwEnd() *IPAddress {
	if m != nil {
		return m.NwEnd
	}
	return nil
}

func (m *Rule_NatTarget) GetTpStart() uint32 {
	if m != nil && m.TpStart != nil {
		return *m.TpStart
	}
	return 0
}

func (m *Rule_NatTarget) GetTpEnd() uint32 {
	if m != nil && m.TpEnd != nil {
		return *m.TpEnd
	}
	return 0
}

type Rule_NatRuleData struct {
	NatTargets []*Rule_NatTarget `protobuf:"bytes,1,rep,name=nat_targets" json:"nat_targets,omitempty"`
	// True if it's a destination NAT rule, otherwise it's a source NAT rule.
	Dnat *bool `protobuf:"varint,2,opt,name=dnat" json:"dnat,omitempty"`
	// True for reverse NAT rules. Reverse NAT rules have no targets.
	Reverse          *bool  `protobuf:"varint,3,opt,name=reverse" json:"reverse,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Rule_NatRuleData) Reset()                    { *m = Rule_NatRuleData{} }
func (m *Rule_NatRuleData) String() string            { return proto.CompactTextString(m) }
func (*Rule_NatRuleData) ProtoMessage()               {}
func (*Rule_NatRuleData) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{18, 2} }

func (m *Rule_NatRuleData) GetNatTargets() []*Rule_NatTarget {
	if m != nil {
		return m.NatTargets
	}
	return nil
}

func (m *Rule_NatRuleData) GetDnat() bool {
	if m != nil && m.Dnat != nil {
		return *m.Dnat
	}
	return false
}

func (m *Rule_NatRuleData) GetReverse() bool {
	if m != nil && m.Reverse != nil {
		return *m.Reverse
	}
	return false
}

type Rule_TraceRuleData struct {
	TraceRequestId   *UUID   `protobuf:"bytes,1,opt,name=trace_request_id" json:"trace_request_id,omitempty"`
	Limit            *uint64 `protobuf:"varint,2,opt,name=limit" json:"limit,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Rule_TraceRuleData) Reset()                    { *m = Rule_TraceRuleData{} }
func (m *Rule_TraceRuleData) String() string            { return proto.CompactTextString(m) }
func (*Rule_TraceRuleData) ProtoMessage()               {}
func (*Rule_TraceRuleData) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{18, 3} }

func (m *Rule_TraceRuleData) GetTraceRequestId() *UUID {
	if m != nil {
		return m.TraceRequestId
	}
	return nil
}

func (m *Rule_TraceRuleData) GetLimit() uint64 {
	if m != nil && m.Limit != nil {
		return *m.Limit
	}
	return 0
}

type Rule_L2TransformRuleData struct {
	PopVlan          *bool   `protobuf:"varint,1,opt,name=pop_vlan" json:"pop_vlan,omitempty"`
	PushVlan         *uint32 `protobuf:"varint,2,opt,name=push_vlan" json:"push_vlan,omitempty"`
	TargetPortId     *UUID   `protobuf:"bytes,3,opt,name=target_port_id" json:"target_port_id,omitempty"`
	Ingress          *bool   `protobuf:"varint,4,opt,name=ingress" json:"ingress,omitempty"`
	FailOpen         *bool   `protobuf:"varint,5,opt,name=fail_open" json:"fail_open,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Rule_L2TransformRuleData) Reset()                    { *m = Rule_L2TransformRuleData{} }
func (m *Rule_L2TransformRuleData) String() string            { return proto.CompactTextString(m) }
func (*Rule_L2TransformRuleData) ProtoMessage()               {}
func (*Rule_L2TransformRuleData) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{18, 4} }

func (m *Rule_L2TransformRuleData) GetPopVlan() bool {
	if m != nil && m.PopVlan != nil {
		return *m.PopVlan
	}
	return false
}

func (m *Rule_L2TransformRuleData) GetPushVlan() uint32 {
	if m != nil && m.PushVlan != nil {
		return *m.PushVlan
	}
	return 0
}

func (m *Rule_L2TransformRuleData) GetTargetPortId() *UUID {
	if m != nil {
		return m.TargetPortId
	}
	return nil
}

func (m *Rule_L2TransformRuleData) GetIngress() bool {
	if m != nil && m.Ingress != nil {
		return *m.Ingress
	}
	return false
}

func (m *Rule_L2TransformRuleData) GetFailOpen() bool {
	if m != nil && m.FailOpen != nil {
		return *m.FailOpen
	}
	return false
}

type TraceRequest struct {
	Id                *UUID      `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Enabled           *bool      `protobuf:"varint,2,opt,name=enabled" json:"enabled,omitempty"`
	Condition         *Condition `protobuf:"bytes,3,opt,name=condition" json:"condition,omitempty"`
	Limit             *uint64    `protobuf:"varint,4,opt,name=limit" json:"limit,omitempty"`
	Name              *string    `protobuf:"bytes,5,opt,name=name" json:"name,omitempty"`
	CreateTimestampMs *uint64    `protobuf:"varint,6,opt,name=create_timestamp_ms" json:"create_timestamp_ms,omitempty"`
	PortId            *UUID      `protobuf:"bytes,101,opt,name=port_id" json:"port_id,omitempty"`
	NetworkId         *UUID      `protobuf:"bytes,102,opt,name=network_id" json:"network_id,omitempty"`
	RouterId          *UUID      `protobuf:"bytes,103,opt,name=router_id" json:"router_id,omitempty"`
	XXX_unrecognized  []byte     `json:"-"`
}

func (m *TraceRequest) Reset()                    { *m = TraceRequest{} }
func (m *TraceRequest) String() string            { return proto.CompactTextString(m) }
func (*TraceRequest) ProtoMessage()               {}
func (*TraceRequest) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{19} }

func (m *TraceRequest) GetId() *UUID {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *TraceRequest) GetEnabled() bool {
	if m != nil && m.Enabled != nil {
		return *m.Enabled
	}
	return false
}

func (m *TraceRequest) GetCondition() *Condition {
	if m != nil {
		return m.Condition
	}
	return nil
}

func (m *TraceRequest) GetLimit() uint64 {
	if m != nil && m.Limit != nil {
		return *m.Limit
	}
	return 0
}

func (m *TraceRequest) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *TraceRequest) GetCreateTimestampMs() uint64 {
	if m != nil && m.CreateTimestampMs != nil {
		return *m.CreateTimestampMs
	}
	return 0
}

func (m *TraceRequest) GetPortId() *UUID {
	if m != nil {
		return m.PortId
	}
	return nil
}

func (m *TraceRequest) GetNetworkId() *UUID {
	if m != nil {
		return m.NetworkId
	}
	return nil
}

func (m *TraceRequest) GetRouterId() *UUID {
	if m != nil {
		return m.RouterId
	}
	return nil
}

type TunnelZone struct {
	Id    *UUID                  `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Name  *string                `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	Type  *TunnelZone_Type       `protobuf:"varint,3,opt,name=type,enum=org.midonet.cluster.models.TunnelZone_Type" json:"type,omitempty"`
	Hosts []*TunnelZone_HostToIp `protobuf:"bytes,4,rep,name=hosts" json:"hosts,omitempty"`
	// Tunnel zone member host IDs.
	// Note: ZOOM cannot yet enforce referential integrity from / to a nested
	// message field, therefore the information is duplicated here and in the
	// "hosts" field above.
	HostIds          []*UUID `protobuf:"bytes,5,rep,name=host_ids" json:"host_ids,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *TunnelZone) Reset()                    { *m = TunnelZone{} }
func (m *TunnelZone) String() string            { return proto.CompactTextString(m) }
func (*TunnelZone) ProtoMessage()               {}
func (*TunnelZone) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{20} }

func (m *TunnelZone) GetId() *UUID {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *TunnelZone) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *TunnelZone) GetType() TunnelZone_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return TunnelZone_GRE
}

func (m *TunnelZone) GetHosts() []*TunnelZone_HostToIp {
	if m != nil {
		return m.Hosts
	}
	return nil
}

func (m *TunnelZone) GetHostIds() []*UUID {
	if m != nil {
		return m.HostIds
	}
	return nil
}

type TunnelZone_HostToIp struct {
	HostId           *UUID      `protobuf:"bytes,1,opt,name=host_id" json:"host_id,omitempty"`
	Ip               *IPAddress `protobuf:"bytes,2,opt,name=ip" json:"ip,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *TunnelZone_HostToIp) Reset()                    { *m = TunnelZone_HostToIp{} }
func (m *TunnelZone_HostToIp) String() string            { return proto.CompactTextString(m) }
func (*TunnelZone_HostToIp) ProtoMessage()               {}
func (*TunnelZone_HostToIp) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{20, 0} }

func (m *TunnelZone_HostToIp) GetHostId() *UUID {
	if m != nil {
		return m.HostId
	}
	return nil
}

func (m *TunnelZone_HostToIp) GetIp() *IPAddress {
	if m != nil {
		return m.Ip
	}
	return nil
}

type Vip struct {
	Id                 *UUID                   `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	AdminStateUp       *bool                   `protobuf:"varint,2,opt,name=admin_state_up" json:"admin_state_up,omitempty"`
	PoolId             *UUID                   `protobuf:"bytes,3,opt,name=pool_id" json:"pool_id,omitempty"`
	Address            *IPAddress              `protobuf:"bytes,4,opt,name=address" json:"address,omitempty"`
	ProtocolPort       *uint32                 `protobuf:"varint,5,opt,name=protocol_port" json:"protocol_port,omitempty"`
	SessionPersistence *Vip_SessionPersistence `protobuf:"varint,6,opt,name=session_persistence,enum=org.midonet.cluster.models.Vip_SessionPersistence" json:"session_persistence,omitempty"`
	GatewayPortId      *UUID                   `protobuf:"bytes,7,opt,name=gateway_port_id" json:"gateway_port_id,omitempty"`
	XXX_unrecognized   []byte                  `json:"-"`
}

func (m *Vip) Reset()                    { *m = Vip{} }
func (m *Vip) String() string            { return proto.CompactTextString(m) }
func (*Vip) ProtoMessage()               {}
func (*Vip) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{21} }

func (m *Vip) GetId() *UUID {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *Vip) GetAdminStateUp() bool {
	if m != nil && m.AdminStateUp != nil {
		return *m.AdminStateUp
	}
	return false
}

func (m *Vip) GetPoolId() *UUID {
	if m != nil {
		return m.PoolId
	}
	return nil
}

func (m *Vip) GetAddress() *IPAddress {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *Vip) GetProtocolPort() uint32 {
	if m != nil && m.ProtocolPort != nil {
		return *m.ProtocolPort
	}
	return 0
}

func (m *Vip) GetSessionPersistence() Vip_SessionPersistence {
	if m != nil && m.SessionPersistence != nil {
		return *m.SessionPersistence
	}
	return Vip_SOURCE_IP
}

func (m *Vip) GetGatewayPortId() *UUID {
	if m != nil {
		return m.GatewayPortId
	}
	return nil
}

type Vtep struct {
	Id               *UUID           `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	ManagementIp     *IPAddress      `protobuf:"bytes,2,opt,name=management_ip" json:"management_ip,omitempty"`
	ManagementPort   *uint32         `protobuf:"varint,3,opt,name=management_port" json:"management_port,omitempty"`
	TunnelZoneId     *UUID           `protobuf:"bytes,4,opt,name=tunnel_zone_id" json:"tunnel_zone_id,omitempty"`
	Bindings         []*Vtep_Binding `protobuf:"bytes,6,rep,name=bindings" json:"bindings,omitempty"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *Vtep) Reset()                    { *m = Vtep{} }
func (m *Vtep) String() string            { return proto.CompactTextString(m) }
func (*Vtep) ProtoMessage()               {}
func (*Vtep) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{22} }

func (m *Vtep) GetId() *UUID {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *Vtep) GetManagementIp() *IPAddress {
	if m != nil {
		return m.ManagementIp
	}
	return nil
}

func (m *Vtep) GetManagementPort() uint32 {
	if m != nil && m.ManagementPort != nil {
		return *m.ManagementPort
	}
	return 0
}

func (m *Vtep) GetTunnelZoneId() *UUID {
	if m != nil {
		return m.TunnelZoneId
	}
	return nil
}

func (m *Vtep) GetBindings() []*Vtep_Binding {
	if m != nil {
		return m.Bindings
	}
	return nil
}

type Vtep_Binding struct {
	PortName         *string `protobuf:"bytes,1,opt,name=port_name" json:"port_name,omitempty"`
	VlanId           *uint32 `protobuf:"varint,2,opt,name=vlan_id" json:"vlan_id,omitempty"`
	NetworkId        *UUID   `protobuf:"bytes,3,opt,name=network_id" json:"network_id,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Vtep_Binding) Reset()                    { *m = Vtep_Binding{} }
func (m *Vtep_Binding) String() string            { return proto.CompactTextString(m) }
func (*Vtep_Binding) ProtoMessage()               {}
func (*Vtep_Binding) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{22, 0} }

func (m *Vtep_Binding) GetPortName() string {
	if m != nil && m.PortName != nil {
		return *m.PortName
	}
	return ""
}

func (m *Vtep_Binding) GetVlanId() uint32 {
	if m != nil && m.VlanId != nil {
		return *m.VlanId
	}
	return 0
}

func (m *Vtep_Binding) GetNetworkId() *UUID {
	if m != nil {
		return m.NetworkId
	}
	return nil
}

func init() {
	proto.RegisterType((*BgpNetwork)(nil), "org.midonet.cluster.models.BgpNetwork")
	proto.RegisterType((*BgpPeer)(nil), "org.midonet.cluster.models.BgpPeer")
	proto.RegisterType((*Chain)(nil), "org.midonet.cluster.models.Chain")
	proto.RegisterType((*Dhcp)(nil), "org.midonet.cluster.models.Dhcp")
	proto.RegisterType((*Dhcp_Opt121Route)(nil), "org.midonet.cluster.models.Dhcp.Opt121Route")
	proto.RegisterType((*Dhcp_Host)(nil), "org.midonet.cluster.models.Dhcp.Host")
	proto.RegisterType((*Dhcp_Host_ExtraDhcpOpt)(nil), "org.midonet.cluster.models.Dhcp.Host.ExtraDhcpOpt")
	proto.RegisterType((*DhcpV6)(nil), "org.midonet.cluster.models.DhcpV6")
	proto.RegisterType((*DhcpV6_Host)(nil), "org.midonet.cluster.models.DhcpV6.Host")
	proto.RegisterType((*HealthMonitor)(nil), "org.midonet.cluster.models.HealthMonitor")
	proto.RegisterType((*Host)(nil), "org.midonet.cluster.models.Host")
	proto.RegisterType((*IPAddrGroup)(nil), "org.midonet.cluster.models.IPAddrGroup")
	proto.RegisterType((*IPAddrGroup_IPAddrPorts)(nil), "org.midonet.cluster.models.IPAddrGroup.IPAddrPorts")
	proto.RegisterType((*L2Insertion)(nil), "org.midonet.cluster.models.L2Insertion")
	proto.RegisterType((*LoadBalancer)(nil), "org.midonet.cluster.models.LoadBalancer")
	proto.RegisterType((*Mirror)(nil), "org.midonet.cluster.models.Mirror")
	proto.RegisterType((*Network)(nil), "org.midonet.cluster.models.Network")
	proto.RegisterType((*Pool)(nil), "org.midonet.cluster.models.Pool")
	proto.RegisterType((*PoolMember)(nil), "org.midonet.cluster.models.PoolMember")
	proto.RegisterType((*Port)(nil), "org.midonet.cluster.models.Port")
	proto.RegisterType((*PortGroup)(nil), "org.midonet.cluster.models.PortGroup")
	proto.RegisterType((*Route)(nil), "org.midonet.cluster.models.Route")
	proto.RegisterType((*Router)(nil), "org.midonet.cluster.models.Router")
	proto.RegisterType((*Rule)(nil), "org.midonet.cluster.models.Rule")
	proto.RegisterType((*Rule_JumpRuleData)(nil), "org.midonet.cluster.models.Rule.JumpRuleData")
	proto.RegisterType((*Rule_NatTarget)(nil), "org.midonet.cluster.models.Rule.NatTarget")
	proto.RegisterType((*Rule_NatRuleData)(nil), "org.midonet.cluster.models.Rule.NatRuleData")
	proto.RegisterType((*Rule_TraceRuleData)(nil), "org.midonet.cluster.models.Rule.TraceRuleData")
	proto.RegisterType((*Rule_L2TransformRuleData)(nil), "org.midonet.cluster.models.Rule.L2TransformRuleData")
	proto.RegisterType((*TraceRequest)(nil), "org.midonet.cluster.models.TraceRequest")
	proto.RegisterType((*TunnelZone)(nil), "org.midonet.cluster.models.TunnelZone")
	proto.RegisterType((*TunnelZone_HostToIp)(nil), "org.midonet.cluster.models.TunnelZone.HostToIp")
	proto.RegisterType((*Vip)(nil), "org.midonet.cluster.models.Vip")
	proto.RegisterType((*Vtep)(nil), "org.midonet.cluster.models.Vtep")
	proto.RegisterType((*Vtep_Binding)(nil), "org.midonet.cluster.models.Vtep.Binding")
	proto.RegisterEnum("org.midonet.cluster.models.Type", Type_name, Type_value)
	proto.RegisterEnum("org.midonet.cluster.models.HealthMonitor_HealthMonitorType", HealthMonitor_HealthMonitorType_name, HealthMonitor_HealthMonitorType_value)
	proto.RegisterEnum("org.midonet.cluster.models.Pool_PoolProtocol", Pool_PoolProtocol_name, Pool_PoolProtocol_value)
	proto.RegisterEnum("org.midonet.cluster.models.Pool_PoolLBMethod", Pool_PoolLBMethod_name, Pool_PoolLBMethod_value)
	proto.RegisterEnum("org.midonet.cluster.models.Pool_PoolHealthMonitorMappingStatus", Pool_PoolHealthMonitorMappingStatus_name, Pool_PoolHealthMonitorMappingStatus_value)
	proto.RegisterEnum("org.midonet.cluster.models.Route_NextHop", Route_NextHop_name, Route_NextHop_value)
	proto.RegisterEnum("org.midonet.cluster.models.Rule_Type", Rule_Type_name, Rule_Type_value)
	proto.RegisterEnum("org.midonet.cluster.models.Rule_Action", Rule_Action_name, Rule_Action_value)
	proto.RegisterEnum("org.midonet.cluster.models.TunnelZone_Type", TunnelZone_Type_name, TunnelZone_Type_value)
	proto.RegisterEnum("org.midonet.cluster.models.Vip_SessionPersistence", Vip_SessionPersistence_name, Vip_SessionPersistence_value)
}

var fileDescriptor1 = []byte{
	// 3000 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xd4, 0x5b, 0x4b, 0x8f, 0xe3, 0x58,
	0x15, 0x9e, 0xbc, 0x93, 0x93, 0x47, 0xa5, 0x53, 0xdd, 0xd3, 0x51, 0x18, 0x31, 0xad, 0x30, 0x30,
	0xc3, 0x3c, 0x02, 0x5d, 0x33, 0x53, 0x33, 0x5d, 0xf3, 0x52, 0x1e, 0xa6, 0x2a, 0xdd, 0x79, 0xe1,
	0x4a, 0x6a, 0x50, 0x83, 0x64, 0x5c, 0x89, 0x93, 0x78, 0xda, 0xb1, 0x8d, 0xed, 0xa4, 0xbb, 0x11,
	0x12, 0x62, 0xc5, 0x92, 0x2d, 0x0b, 0x06, 0x21, 0x24, 0xc4, 0x9e, 0x15, 0x1b, 0x24, 0xc4, 0x02,
	0xb1, 0x1f, 0x89, 0x05, 0x1b, 0xc4, 0x86, 0x05, 0x3f, 0x02, 0x71, 0xee, 0xbd, 0xb6, 0xe3, 0x4c,
	0x57, 0xa7, 0xae, 0x2b, 0xcd, 0x20, 0x36, 0x2d, 0x97, 0xe3, 0x73, 0xee, 0xb9, 0xe7, 0xf9, 0x9d,
	0x73, 0x6f, 0x43, 0xc1, 0x31, 0x4c, 0x43, 0x33, 0x66, 0x8f, 0x6b, 0xa6, 0x65, 0x38, 0x46, 0xa9,
	0x62, 0x58, 0xb3, 0xda, 0x42, 0x9d, 0x18, 0xba, 0xe2, 0xd4, 0xc6, 0xda, 0xd2, 0x76, 0x14, 0xab,
	0xb6, 0x30, 0x26, 0x8a, 0x66, 0x57, 0xf2, 0x63, 0x63, 0xb1, 0x30, 0x74, 0x9b, 0x7d, 0x5a, 0xfd,
	0x4d, 0x04, 0xa0, 0x31, 0x33, 0x7b, 0x8a, 0xf3, 0xd0, 0xb0, 0x1e, 0x94, 0x5e, 0x87, 0xa8, 0x3a,
	0x29, 0x47, 0x6e, 0x45, 0x5e, 0xc9, 0x1e, 0xdc, 0xaa, 0x3d, 0x9d, 0x4d, 0x6d, 0x34, 0x6a, 0xb7,
	0x4a, 0x6f, 0x41, 0xd2, 0x5e, 0x9e, 0xe3, 0xaf, 0xe5, 0x28, 0xa5, 0x78, 0x69, 0x1b, 0x45, 0x7b,
	0x70, 0x4a, 0xbf, 0x2d, 0xbd, 0x09, 0x19, 0xcb, 0x58, 0xe2, 0x2f, 0x12, 0x2e, 0x15, 0xe3, 0x5b,
	0xaa, 0xfa, 0xd3, 0x28, 0xa4, 0x50, 0xce, 0x81, 0xa2, 0x58, 0x21, 0x85, 0xbc, 0x06, 0x19, 0xd9,
	0x96, 0xf4, 0xe5, 0xe2, 0x5c, 0xb1, 0xa8, 0x9c, 0x89, 0xd2, 0x21, 0xa4, 0xe4, 0xc9, 0xc4, 0x52,
	0x6c, 0xdb, 0x5d, 0xff, 0xab, 0xdb, 0x05, 0xaf, 0xb3, 0x8f, 0x4b, 0x25, 0x80, 0x07, 0x8a, 0x62,
	0x4a, 0xb2, 0xa6, 0xae, 0x94, 0x72, 0x9c, 0xf2, 0x42, 0xf6, 0x73, 0x43, 0x9b, 0x48, 0x8e, 0xba,
	0x50, 0xca, 0x09, 0xfa, 0xea, 0x06, 0xa0, 0x92, 0x75, 0x5d, 0x19, 0x3b, 0x92, 0xa5, 0x38, 0xd6,
	0xe3, 0x72, 0x92, 0xbe, 0x2e, 0x42, 0xda, 0x94, 0x6d, 0x1b, 0xf5, 0x3c, 0x29, 0xa7, 0xf1, 0x4d,
	0x66, 0x53, 0x13, 0x29, 0x4e, 0x4d, 0xfc, 0x3e, 0x0e, 0x89, 0xe6, 0x5c, 0x56, 0xf5, 0x90, 0x7a,
	0xc8, 0x41, 0x5c, 0x97, 0x51, 0xc6, 0x28, 0x5d, 0x1a, 0xc5, 0x76, 0x14, 0x5d, 0xd6, 0x1d, 0xcf,
	0x08, 0x99, 0xd2, 0x01, 0xa4, 0xad, 0xa5, 0xa6, 0xe0, 0x0b, 0xbb, 0xac, 0xdc, 0x8a, 0x71, 0x31,
	0xfd, 0x00, 0xf6, 0x75, 0xe6, 0x3a, 0x92, 0xaa, 0x9f, 0x1b, 0x4b, 0x7d, 0x42, 0xc9, 0xa7, 0x9c,
	0xe4, 0x1f, 0xc2, 0x75, 0x8f, 0x1c, 0xf5, 0xb0, 0xa6, 0x9f, 0x71, 0xd2, 0xbf, 0x0f, 0x25, 0x4f,
	0x81, 0x81, 0xd5, 0xe7, 0xfc, 0xc2, 0xbb, 0xd4, 0x1b, 0x8b, 0xab, 0x9c, 0xe4, 0x47, 0x50, 0x34,
	0x0d, 0xcb, 0xd9, 0x58, 0xfa, 0x13, 0x4e, 0xda, 0xf7, 0xe0, 0x1a, 0xa5, 0xdd, 0x58, 0xf8, 0x01,
	0x27, 0xf1, 0x3b, 0x90, 0xff, 0x64, 0xb9, 0x30, 0x25, 0xdf, 0x5a, 0x1a, 0x1f, 0x61, 0xf5, 0x1f,
	0x29, 0x88, 0xb7, 0xe6, 0x63, 0x33, 0x74, 0x98, 0x83, 0x6f, 0xe4, 0x89, 0x1b, 0xea, 0x3c, 0xb6,
	0x29, 0xb0, 0xe4, 0x20, 0x6d, 0xc6, 0x1a, 0x5f, 0x92, 0xf8, 0x00, 0xa9, 0x15, 0x6b, 0x85, 0xb6,
	0xf1, 0xa8, 0xe3, 0x61, 0x22, 0xb5, 0x0e, 0xa5, 0x89, 0x6e, 0x4b, 0x9f, 0x63, 0x91, 0xa0, 0x7a,
	0xe2, 0x64, 0xf1, 0x21, 0xec, 0x4d, 0x94, 0xa9, 0xbc, 0xd4, 0x1c, 0x69, 0x26, 0x3b, 0xca, 0x43,
	0x99, 0xc5, 0x31, 0x37, 0x3d, 0x66, 0x01, 0x55, 0xc7, 0x5f, 0xa6, 0xf2, 0x58, 0x91, 0x16, 0xce,
	0x92, 0x06, 0x78, 0xa2, 0xd4, 0x84, 0xbc, 0x61, 0x3a, 0xb7, 0x0f, 0x6e, 0x4b, 0xd4, 0xf7, 0x6c,
	0x4c, 0x05, 0x44, 0xa8, 0xd7, 0xb7, 0x31, 0x25, 0x36, 0xab, 0xf5, 0x29, 0x95, 0x48, 0x88, 0xd0,
	0x22, 0x89, 0xb9, 0x61, 0x3b, 0x76, 0x39, 0x73, 0xf9, 0x8e, 0x28, 0xf1, 0x09, 0x7e, 0x5d, 0xda,
	0x83, 0x14, 0x86, 0xfc, 0xb9, 0xa6, 0x4c, 0xca, 0x80, 0xb2, 0xa4, 0x89, 0x17, 0x7a, 0xe1, 0x33,
	0x95, 0x98, 0x2f, 0x4f, 0x30, 0xf4, 0x23, 0xbc, 0x2e, 0xec, 0xea, 0x85, 0xed, 0x24, 0x4c, 0xe0,
	0x57, 0x7e, 0x0c, 0xd9, 0xe0, 0x7e, 0xde, 0x05, 0x98, 0xd8, 0x8e, 0xe4, 0x16, 0x93, 0x48, 0x08,
	0x3f, 0xc1, 0x54, 0xee, 0x59, 0x27, 0x1a, 0xc2, 0x3a, 0x95, 0xbf, 0x46, 0x20, 0x4e, 0x95, 0x92,
	0x85, 0xd8, 0x42, 0x1e, 0xd3, 0x35, 0x33, 0xa5, 0x3b, 0x00, 0xaa, 0xe9, 0xbb, 0x4b, 0x18, 0x86,
	0x7e, 0x7a, 0x65, 0xb9, 0xf4, 0x1e, 0xec, 0x29, 0x8f, 0x1c, 0x4b, 0x96, 0x26, 0xa8, 0x7d, 0x09,
	0x0d, 0x4e, 0xfc, 0x97, 0xa8, 0xe6, 0x80, 0xcb, 0x54, 0x35, 0x81, 0x10, 0x93, 0x3f, 0x51, 0x4b,
	0x95, 0xd7, 0x20, 0x17, 0xfc, 0xdb, 0x5f, 0x8a, 0xc9, 0x9c, 0x87, 0xc4, 0x4a, 0xd6, 0x96, 0x6e,
	0x62, 0xaf, 0xfe, 0x39, 0x0a, 0x49, 0xf2, 0xe1, 0xd9, 0xe1, 0xff, 0x41, 0x94, 0x1f, 0x7a, 0x7e,
	0xcc, 0x94, 0xf3, 0xf2, 0x65, 0xca, 0x39, 0x3b, 0xa4, 0xea, 0xa9, 0x9c, 0xbb, 0xc6, 0xc3, 0x2a,
	0x36, 0xd6, 0x54, 0x85, 0x55, 0xb1, 0x67, 0x6b, 0xc2, 0xea, 0xbf, 0xa2, 0x90, 0x3f, 0x51, 0x64,
	0xcd, 0x99, 0x77, 0x0d, 0x5d, 0x75, 0x8c, 0xb0, 0xb8, 0xe3, 0x79, 0x28, 0xc8, 0x93, 0x85, 0xaa,
	0x4b, 0xb6, 0x83, 0x0e, 0x2a, 0x2d, 0x4d, 0x2a, 0x4c, 0xba, 0xd4, 0x83, 0xb8, 0xf3, 0xd8, 0x64,
	0xab, 0x14, 0x0e, 0xde, 0xdb, 0xc6, 0x67, 0x63, 0xf9, 0xcd, 0xbf, 0x86, 0xc8, 0xe2, 0x28, 0x36,
	0x6c, 0x0e, 0xd0, 0x02, 0x49, 0xb2, 0xc2, 0x92, 0x65, 0xc8, 0xc2, 0x76, 0xcd, 0x77, 0x1a, 0xa7,
	0xf4, 0xdb, 0xa3, 0x64, 0xbd, 0x39, 0x6c, 0x9f, 0x09, 0xc4, 0x7b, 0xf0, 0x07, 0x8c, 0x1e, 0x06,
	0x5d, 0x30, 0x45, 0x10, 0x20, 0x83, 0x41, 0xe9, 0x82, 0x96, 0x7d, 0xc8, 0x2e, 0xe4, 0x47, 0x14,
	0xc7, 0xa8, 0x98, 0xac, 0x58, 0x0e, 0x43, 0xa4, 0x60, 0x1a, 0x86, 0x16, 0x06, 0x29, 0x54, 0x5f,
	0x80, 0x6b, 0x4f, 0x6c, 0xa0, 0x94, 0x02, 0xb2, 0x85, 0x62, 0xa4, 0xfa, 0x99, 0x17, 0x8e, 0xbb,
	0x60, 0x9a, 0x5b, 0x70, 0x63, 0xaa, 0x19, 0xc6, 0x44, 0xd5, 0x67, 0x12, 0xa2, 0xdb, 0x47, 0x8f,
	0xa5, 0x87, 0x8a, 0x3a, 0x9b, 0x3b, 0x54, 0xd5, 0x89, 0xa3, 0xc8, 0x6d, 0x74, 0x8e, 0x3d, 0x67,
	0x89, 0xc8, 0x4c, 0x93, 0x7e, 0x88, 0x3c, 0x43, 0x21, 0x1d, 0xba, 0x67, 0x9a, 0x21, 0xb9, 0xb3,
	0x5c, 0xf5, 0x8f, 0x31, 0xc8, 0x32, 0xf7, 0x3a, 0xc6, 0x14, 0x69, 0xee, 0xb4, 0xb9, 0xbb, 0x58,
	0x4e, 0x98, 0x5f, 0xd3, 0x4c, 0x4d, 0xe2, 0x8c, 0x08, 0xf1, 0xe6, 0xe5, 0xae, 0x4d, 0xd7, 0x76,
	0x9f, 0x07, 0x84, 0x94, 0x20, 0x17, 0x0f, 0xb4, 0x8c, 0x09, 0x92, 0x24, 0xd1, 0x13, 0xe7, 0x4f,
	0xfb, 0x3e, 0x68, 0xf1, 0x89, 0x13, 0x9c, 0xc4, 0x41, 0x88, 0x99, 0xe4, 0x2c, 0x15, 0x3f, 0xf2,
	0x74, 0xc8, 0x64, 0xdf, 0x8c, 0xef, 0x48, 0x98, 0xf8, 0x0e, 0x9a, 0x30, 0xca, 0x69, 0xc2, 0xbf,
	0x45, 0x21, 0xdb, 0x39, 0x68, 0xeb, 0x88, 0x24, 0x1c, 0xd5, 0x08, 0x8b, 0xb9, 0x6f, 0x43, 0xca,
	0x2b, 0xab, 0xbc, 0x09, 0xf5, 0x6d, 0xc8, 0xda, 0xd6, 0xca, 0xaf, 0xc6, 0x31, 0x7e, 0x67, 0x59,
	0x69, 0xb2, 0x4e, 0xcd, 0x98, 0x27, 0x79, 0x71, 0x2a, 0xab, 0x1a, 0x16, 0x1e, 0x45, 0xa7, 0xc6,
	0x49, 0xd3, 0xee, 0xc3, 0xb0, 0x55, 0xb2, 0x09, 0x1a, 0xda, 0x79, 0xaf, 0xf2, 0xa5, 0xa8, 0x7b,
	0xbd, 0x8b, 0x79, 0x1c, 0x97, 0x65, 0xd6, 0xa1, 0x36, 0x9d, 0x70, 0xae, 0x8c, 0x31, 0xe5, 0x53,
	0xa2, 0x67, 0x84, 0x80, 0x10, 0xd5, 0x3f, 0x44, 0x20, 0xd7, 0x31, 0xe4, 0x49, 0x43, 0x46, 0xd1,
	0xc7, 0xca, 0xb3, 0xca, 0xb0, 0x1b, 0x6d, 0x95, 0xc2, 0xef, 0x9a, 0x7e, 0x4e, 0xe3, 0x8d, 0xef,
	0x5f, 0xc4, 0x21, 0xd9, 0x55, 0x2d, 0x2b, 0x74, 0x6d, 0xc0, 0x5a, 0xeb, 0x18, 0x52, 0x58, 0xd7,
	0x40, 0xd7, 0xc7, 0xbe, 0x72, 0x42, 0x6d, 0xe8, 0xc5, 0xff, 0x56, 0xd7, 0x6f, 0x7a, 0x5f, 0x3f,
	0xad, 0x4f, 0x53, 0x76, 0xec, 0xd3, 0xa6, 0x3b, 0xf5, 0x69, 0xb3, 0xdd, 0xfa, 0xb4, 0xf9, 0x0e,
	0x7d, 0x9a, 0xba, 0x4b, 0x9f, 0xc6, 0xd9, 0xe4, 0x55, 0x7f, 0x99, 0x80, 0xd4, 0xd5, 0x06, 0x2b,
	0x1b, 0xdd, 0x39, 0xcb, 0xff, 0x9b, 0xf8, 0xf2, 0x49, 0xd7, 0x8f, 0x53, 0xd7, 0x2f, 0xa1, 0x63,
	0xb1, 0x02, 0xf7, 0x40, 0x61, 0x35, 0x3d, 0x4e, 0xf6, 0xe0, 0x6d, 0x7d, 0xaa, 0x6a, 0x6e, 0x58,
	0x24, 0xb9, 0xf1, 0x5d, 0xc9, 0xdf, 0xfb, 0x9a, 0x9a, 0x73, 0x56, 0x41, 0x52, 0xcc, 0x4a, 0x57,
	0xe9, 0xb4, 0x23, 0x4f, 0x58, 0x79, 0x72, 0x2c, 0x68, 0xd0, 0x50, 0x65, 0x66, 0xf8, 0x9d, 0xc0,
	0x17, 0x24, 0x40, 0x0e, 0x57, 0x28, 0xdf, 0xbc, 0x5e, 0x8f, 0x39, 0x71, 0xf5, 0x08, 0x33, 0x93,
	0x14, 0xb6, 0xf0, 0x93, 0xd5, 0x28, 0xf0, 0x0f, 0xe3, 0xe5, 0x98, 0x13, 0x08, 0xcd, 0xea, 0x30,
	0x94, 0x73, 0xa3, 0x71, 0xb1, 0x33, 0xc0, 0x0e, 0xd3, 0x52, 0x7e, 0xb0, 0x54, 0x6c, 0x27, 0x8c,
	0x77, 0x57, 0x3f, 0x4d, 0x42, 0x7c, 0x80, 0x49, 0x2f, 0xa4, 0x77, 0xe2, 0x9a, 0x73, 0x0a, 0xe5,
	0xa4, 0x05, 0xc3, 0x72, 0x61, 0x92, 0x18, 0x46, 0xa3, 0x86, 0x29, 0x5f, 0x3a, 0x77, 0x73, 0x7e,
	0x98, 0x22, 0xf7, 0x34, 0xaf, 0x6f, 0xa1, 0x71, 0xc9, 0x34, 0x73, 0x6c, 0x68, 0xd4, 0xe7, 0x0b,
	0x07, 0x6f, 0x6c, 0xe3, 0x45, 0xb6, 0x4c, 0xff, 0x19, 0xb8, 0x44, 0x0c, 0x48, 0x77, 0x21, 0xa3,
	0x9d, 0x4b, 0x0b, 0xc5, 0x99, 0x1b, 0x2c, 0x3e, 0x78, 0xd9, 0x74, 0x1a, 0x5d, 0x4a, 0x74, 0x94,
	0x15, 0xfb, 0xa3, 0x5e, 0x4b, 0x12, 0xfb, 0x8d, 0x76, 0x2f, 0x80, 0xcb, 0x53, 0x57, 0xc0, 0xe5,
	0x1f, 0x43, 0x61, 0x21, 0x9b, 0x26, 0x81, 0xb2, 0x2e, 0x97, 0x34, 0xe5, 0xf2, 0x11, 0x97, 0x44,
	0x1b, 0x48, 0xbb, 0xcb, 0xf8, 0xb0, 0x05, 0x48, 0xb9, 0xa6, 0x75, 0x6e, 0xa1, 0x90, 0x81, 0x68,
	0xa8, 0x78, 0x40, 0x34, 0xb3, 0x52, 0xcd, 0x50, 0x15, 0xf2, 0x26, 0xe4, 0x82, 0x8a, 0x5e, 0x03,
	0xfe, 0x17, 0xd9, 0x0f, 0x9e, 0xea, 0xb0, 0xf1, 0x08, 0x2a, 0x0f, 0x3f, 0xf8, 0x49, 0x04, 0xbe,
	0x7c, 0xc9, 0x56, 0x00, 0x5c, 0x6d, 0x15, 0x23, 0x98, 0x1e, 0xd3, 0xed, 0x9e, 0xfb, 0x57, 0x14,
	0xd3, 0x60, 0x61, 0x20, 0xf4, 0x5a, 0xed, 0xde, 0xb1, 0xd4, 0x14, 0x85, 0xfa, 0x50, 0x28, 0xc6,
	0x82, 0xef, 0x46, 0x83, 0x16, 0x79, 0x17, 0x0f, 0xbe, 0x6b, 0x09, 0x1d, 0x01, 0xdf, 0x25, 0x4a,
	0x19, 0x48, 0x08, 0xa2, 0xd8, 0x17, 0x8b, 0xc9, 0xea, 0xaf, 0xa3, 0x00, 0x44, 0x86, 0x2e, 0xd5,
	0xd5, 0x33, 0x42, 0x27, 0x14, 0x13, 0x52, 0xa0, 0xc1, 0xed, 0xf7, 0xbb, 0xb5, 0x78, 0x81, 0x69,
	0x77, 0x22, 0xe4, 0x00, 0xcb, 0x8b, 0x2a, 0x9a, 0x01, 0xdd, 0x8e, 0xb0, 0x00, 0x49, 0xb7, 0xad,
	0xa2, 0xcd, 0x60, 0xf5, 0x2f, 0x59, 0x92, 0x44, 0x2c, 0xe7, 0x0b, 0x19, 0x37, 0x5c, 0xe5, 0xec,
	0xe0, 0xe2, 0x02, 0x18, 0xdf, 0xa9, 0x00, 0xf2, 0x36, 0x3c, 0x9b, 0xf5, 0x38, 0x49, 0xeb, 0x31,
	0x71, 0x00, 0x25, 0x5c, 0x1d, 0xfd, 0x26, 0x24, 0x57, 0xea, 0x94, 0x50, 0xa4, 0xf9, 0x3b, 0x0f,
	0x32, 0x59, 0x21, 0x24, 0x19, 0x7e, 0x87, 0x5d, 0x0f, 0x2c, 0x29, 0xd6, 0x00, 0x8a, 0x35, 0x5e,
	0x78, 0xc2, 0x91, 0xb3, 0xc4, 0x91, 0x8f, 0xe2, 0x8e, 0xb5, 0x24, 0xa3, 0xbb, 0x02, 0x2d, 0x8f,
	0x33, 0xd2, 0x65, 0xd2, 0xdc, 0x90, 0xe3, 0x4c, 0x27, 0x7b, 0x98, 0x4e, 0x48, 0x75, 0x45, 0x11,
	0xf3, 0x14, 0x20, 0xdc, 0x81, 0x2c, 0x65, 0xe5, 0x8e, 0x01, 0x0b, 0x21, 0x06, 0x49, 0xef, 0x41,
	0x8e, 0x92, 0x7a, 0x8e, 0xbe, 0x17, 0xc6, 0xd1, 0x8b, 0x2e, 0x36, 0x20, 0xdd, 0x50, 0x71, 0xe3,
	0x60, 0x86, 0xee, 0xe7, 0x1a, 0x7f, 0x7a, 0x74, 0x8b, 0x7e, 0xb9, 0xc4, 0x6f, 0xa5, 0x95, 0xa3,
	0x50, 0x92, 0x7d, 0x7e, 0x7f, 0xbc, 0x00, 0x45, 0x5d, 0xdf, 0x0d, 0x45, 0xdd, 0xe0, 0x24, 0xaf,
	0xc3, 0x4d, 0xed, 0x40, 0xf5, 0x9a, 0x61, 0x44, 0xd4, 0xeb, 0x88, 0xb8, 0xc9, 0x29, 0x7f, 0x03,
	0xca, 0x41, 0x16, 0x28, 0xcd, 0x9a, 0x47, 0x39, 0x84, 0xda, 0xdc, 0x42, 0xa4, 0xf0, 0x37, 0x01,
	0x53, 0x24, 0xd1, 0x65, 0x67, 0x7d, 0x6c, 0x32, 0xdd, 0x05, 0x63, 0x85, 0x80, 0x75, 0x01, 0x45,
	0xcf, 0xf9, 0x8f, 0x78, 0x02, 0x6a, 0x46, 0x42, 0x9d, 0x5f, 0x56, 0xd2, 0x8d, 0x6f, 0x12, 0x1b,
	0x9c, 0xd5, 0xfa, 0x57, 0x11, 0xc8, 0x90, 0x54, 0xbe, 0xfb, 0xb4, 0xea, 0x82, 0xe3, 0x45, 0x8c,
	0x32, 0x9a, 0x40, 0xa6, 0x4b, 0xcd, 0x85, 0x6d, 0x57, 0xc0, 0xe4, 0xd5, 0xdf, 0xc5, 0x21, 0xc1,
	0xce, 0x0c, 0xc2, 0x89, 0xf7, 0x2e, 0x80, 0x6d, 0x8d, 0xa5, 0x2b, 0x1c, 0x57, 0x6f, 0x9e, 0x4d,
	0xc4, 0x42, 0x25, 0xa5, 0xb4, 0xae, 0x3c, 0x72, 0xa4, 0xb9, 0x61, 0xba, 0x85, 0xfb, 0xeb, 0xdb,
	0xe8, 0xe8, 0xb6, 0x6a, 0x3d, 0xa4, 0x38, 0x31, 0x4c, 0xe2, 0xb0, 0x1e, 0xb1, 0x3f, 0x28, 0xe0,
	0xad, 0x3a, 0xeb, 0x12, 0xcd, 0x4a, 0x36, 0x56, 0x21, 0xd9, 0x71, 0x2c, 0xf5, 0x9c, 0x1e, 0x38,
	0xa5, 0x9e, 0x3c, 0x7b, 0xe6, 0xad, 0x2a, 0x1f, 0x05, 0x84, 0xf2, 0x8e, 0x5d, 0x32, 0x61, 0x52,
	0x2d, 0xa2, 0x4f, 0xef, 0xd0, 0xc8, 0xcb, 0x95, 0xc0, 0x39, 0x2c, 0xba, 0x43, 0x9a, 0x69, 0xa6,
	0x9b, 0x3c, 0x64, 0x1a, 0x9d, 0x7a, 0xf3, 0xde, 0x49, 0xbf, 0x23, 0x14, 0x9f, 0x23, 0x38, 0x50,
	0x14, 0xee, 0x0a, 0xcd, 0x21, 0xe2, 0xc0, 0x34, 0x82, 0x91, 0xbe, 0x38, 0x44, 0x0c, 0x88, 0x38,
	0xae, 0xd3, 0x6f, 0xd6, 0x3b, 0xc5, 0x58, 0xf5, 0xb3, 0x04, 0x7e, 0x41, 0x37, 0xfb, 0x45, 0xf5,
	0xe1, 0x17, 0x42, 0x8e, 0xc4, 0x4e, 0x90, 0x23, 0xb9, 0x43, 0x83, 0x95, 0x0a, 0x09, 0xaf, 0x68,
	0x48, 0xa6, 0x39, 0x53, 0xce, 0x8d, 0xe0, 0x05, 0x8b, 0x0c, 0x1d, 0xb5, 0x47, 0xdf, 0xa0, 0xb3,
	0xf6, 0xf3, 0x19, 0x66, 0x5c, 0x1f, 0xe4, 0xf1, 0x37, 0xeb, 0x87, 0x90, 0x23, 0xa4, 0x2e, 0x4a,
	0xb2, 0x11, 0x6f, 0xc4, 0x76, 0xa8, 0x8d, 0xb9, 0xdd, 0x6a, 0x63, 0xfe, 0xbf, 0x38, 0x61, 0xb8,
	0xb0, 0xb2, 0xf0, 0xf6, 0x56, 0xbf, 0x45, 0xe0, 0x2d, 0x62, 0x2d, 0x0b, 0xe9, 0xd3, 0x6f, 0xba,
	0xe7, 0x4f, 0x51, 0x9a, 0x91, 0xb6, 0xc6, 0x2d, 0xe1, 0x5e, 0xa3, 0x07, 0x35, 0xb8, 0x39, 0x7f,
	0xd8, 0xcf, 0x0b, 0xbb, 0xdf, 0x81, 0xa4, 0x3c, 0xa6, 0xf3, 0x66, 0x96, 0xfc, 0x5e, 0xbe, 0x74,
	0xa9, 0x3a, 0xfd, 0x1c, 0x33, 0x6e, 0xc6, 0x9f, 0x73, 0xf2, 0xb4, 0x2c, 0xeb, 0x31, 0xe7, 0xdb,
	0x90, 0x25, 0x55, 0xde, 0xcb, 0x97, 0xbc, 0x21, 0x73, 0x0c, 0x85, 0xf5, 0x85, 0x8a, 0x89, 0xec,
	0xc8, 0xee, 0xf0, 0xfb, 0x8d, 0x4b, 0x25, 0xbe, 0x8b, 0x64, 0xe4, 0xa1, 0x85, 0x44, 0x27, 0xcf,
	0x95, 0x04, 0xc8, 0xfb, 0x08, 0x83, 0xf2, 0x61, 0xd3, 0xe7, 0xd7, 0x2f, 0xe5, 0xd3, 0x93, 0x9d,
	0x00, 0x9b, 0x36, 0xec, 0xb9, 0x6e, 0xe1, 0x33, 0x9a, 0x52, 0x46, 0xb5, 0xcb, 0xad, 0x45, 0xe8,
	0x02, 0xac, 0x4e, 0x61, 0x1f, 0x59, 0xe9, 0xf6, 0xd4, 0xb0, 0x16, 0x01, 0x76, 0x33, 0xca, 0xee,
	0xad, 0x4b, 0xd9, 0x75, 0x0e, 0x86, 0x1e, 0xf5, 0x9a, 0x69, 0xe5, 0xfb, 0x90, 0x0b, 0x6e, 0xdc,
	0xbf, 0x90, 0xe2, 0xbb, 0x08, 0xaf, 0x2f, 0xde, 0x84, 0xbd, 0x00, 0xe1, 0x1a, 0x3f, 0x54, 0x3e,
	0x45, 0x24, 0x82, 0x3a, 0x19, 0xca, 0xd6, 0x0c, 0x0b, 0xe9, 0x3b, 0x58, 0x48, 0x1f, 0x92, 0x14,
	0x6b, 0x39, 0xe1, 0x4e, 0x7c, 0xde, 0x86, 0x24, 0x12, 0x2a, 0xfa, 0x24, 0xdc, 0x41, 0x30, 0x42,
	0x15, 0xc7, 0x74, 0xd7, 0x8b, 0xd1, 0xd6, 0x04, 0x2b, 0x2a, 0xbe, 0x21, 0x8c, 0xe8, 0x01, 0x4b,
	0x65, 0x01, 0xd9, 0x80, 0xc9, 0xb0, 0x2e, 0x66, 0x89, 0xdd, 0x1d, 0x2a, 0x2e, 0x39, 0x95, 0x22,
	0x11, 0xfc, 0x2a, 0x8f, 0xd5, 0xdd, 0x1d, 0x62, 0x55, 0x99, 0x20, 0x07, 0x77, 0x44, 0x80, 0x9d,
	0x91, 0xa5, 0xac, 0x14, 0xcb, 0x66, 0x65, 0x26, 0x5d, 0xb9, 0x0f, 0xf9, 0x0d, 0xc3, 0x92, 0x24,
	0xff, 0xf9, 0xc4, 0xc1, 0xad, 0xf4, 0x3c, 0x24, 0x34, 0x75, 0xa1, 0xb2, 0xc5, 0xe2, 0x95, 0x9f,
	0x47, 0x60, 0xff, 0x02, 0x33, 0xb3, 0xae, 0xc8, 0x94, 0xe8, 0xa9, 0x52, 0x84, 0x8a, 0x85, 0xd5,
	0xd0, 0x5c, 0xda, 0x73, 0xf6, 0x2a, 0x4a, 0xf5, 0x82, 0xdd, 0x1f, 0xdb, 0x74, 0xe8, 0x03, 0x2b,
	0xdc, 0xa3, 0xaa, 0xcf, 0xfc, 0x9b, 0x3d, 0xe9, 0x0b, 0xce, 0xac, 0xaa, 0xdf, 0x85, 0x38, 0xcd,
	0x3e, 0x45, 0xc8, 0x75, 0xda, 0x43, 0x41, 0xac, 0x77, 0x24, 0x71, 0xd4, 0x71, 0xc7, 0x3d, 0xbd,
	0xfa, 0x90, 0xfd, 0x15, 0x25, 0x78, 0xe0, 0xee, 0xa8, 0x3b, 0x60, 0x7f, 0xc6, 0xd0, 0x58, 0x30,
	0x14, 0xeb, 0x4d, 0x81, 0xfd, 0x1d, 0x2f, 0x5d, 0x87, 0x22, 0x6e, 0x50, 0xac, 0xf7, 0x4e, 0xbf,
	0xd5, 0x17, 0xbb, 0xec, 0x6d, 0xa2, 0xfa, 0x3d, 0x48, 0xba, 0xf9, 0x86, 0xce, 0x91, 0x9a, 0xc2,
	0x60, 0xc8, 0x18, 0x37, 0xfb, 0xbd, 0x61, 0xbb, 0x37, 0x22, 0x8c, 0x11, 0x4d, 0xb4, 0xc4, 0xfe,
	0x00, 0x79, 0xe2, 0x13, 0x59, 0x02, 0xb9, 0xad, 0xd1, 0x46, 0x82, 0x3d, 0x0f, 0x47, 0x62, 0xaf,
	0x98, 0x24, 0x94, 0xa2, 0xd0, 0x6a, 0x8b, 0xe4, 0x97, 0x54, 0x23, 0x8b, 0x95, 0xd4, 0x8b, 0xb6,
	0xea, 0xdf, 0xa3, 0x90, 0x63, 0xf6, 0x63, 0xd6, 0x0a, 0x99, 0xb1, 0x03, 0xf7, 0x76, 0x98, 0x7f,
	0x6c, 0x24, 0xc8, 0x58, 0x98, 0x04, 0xe9, 0xdb, 0x3e, 0x4e, 0x47, 0x11, 0x1e, 0x98, 0x49, 0x50,
	0x30, 0xf3, 0x25, 0xd8, 0x1f, 0x5b, 0x0a, 0xc1, 0x31, 0xe4, 0x0e, 0x00, 0xba, 0x3f, 0x46, 0xe6,
	0xc2, 0x0e, 0x4c, 0x2d, 0x42, 0xde, 0x10, 0xda, 0x1c, 0xf1, 0x4c, 0xaf, 0x32, 0xe2, 0x99, 0x71,
	0x82, 0xc3, 0x9f, 0xc5, 0xd0, 0xe6, 0x74, 0xd0, 0x72, 0x1f, 0xbf, 0xd9, 0xa9, 0x75, 0xb9, 0xb3,
	0x71, 0x3f, 0xe3, 0xb5, 0x6d, 0xd4, 0xeb, 0x15, 0x59, 0x95, 0xfc, 0x70, 0xf3, 0x3a, 0xcb, 0x37,
	0x38, 0x69, 0xc9, 0xc5, 0x87, 0xa1, 0xd1, 0x36, 0x49, 0x95, 0x75, 0x87, 0x36, 0xde, 0x5d, 0xb5,
	0xcb, 0x8f, 0xc7, 0x4d, 0x48, 0xfb, 0xf4, 0x81, 0xa1, 0x0f, 0xff, 0x09, 0x75, 0x54, 0x35, 0x43,
	0x65, 0xc7, 0xea, 0x4b, 0x6e, 0x54, 0xa6, 0x20, 0x76, 0x2c, 0x92, 0x60, 0x44, 0xa4, 0x7d, 0xf6,
	0x9d, 0x4e, 0xbd, 0xc7, 0x02, 0xe6, 0x6c, 0x28, 0x60, 0xc0, 0x54, 0xff, 0x1d, 0x85, 0xd8, 0x99,
	0x6a, 0xfe, 0xef, 0x86, 0xa6, 0x81, 0xb1, 0x67, 0x7c, 0xa7, 0xb1, 0x67, 0x82, 0x66, 0xba, 0x3e,
	0xec, 0xdb, 0xf8, 0x33, 0x69, 0xa9, 0x4d, 0xcc, 0xcc, 0x2a, 0x12, 0x23, 0xba, 0x76, 0xcf, 0x09,
	0xb6, 0xde, 0xea, 0x42, 0x2d, 0xd4, 0x4e, 0x19, 0xe9, 0x60, 0x4d, 0x19, 0x6c, 0x85, 0xbc, 0xc0,
	0xe2, 0xbd, 0x02, 0xfc, 0x15, 0x28, 0x5d, 0xc0, 0x10, 0xb3, 0xe0, 0x69, 0x7f, 0x24, 0x62, 0xde,
	0x6b, 0x93, 0x09, 0xfb, 0x3f, 0xa3, 0x68, 0x0b, 0x47, 0x09, 0x6b, 0x81, 0xf7, 0x21, 0xbf, 0x90,
	0x75, 0x79, 0xa6, 0x2c, 0xe8, 0xb5, 0xaa, 0x70, 0xbe, 0x41, 0x0a, 0x7a, 0x80, 0x9a, 0xaa, 0x2f,
	0xe6, 0x17, 0x8a, 0x8d, 0x9b, 0x37, 0xdc, 0x03, 0xd8, 0x23, 0x48, 0x9f, 0xab, 0x3a, 0xb9, 0xd4,
	0xe3, 0xdd, 0x19, 0x79, 0x65, 0xab, 0xb6, 0x71, 0xcb, 0xb5, 0x06, 0x23, 0xa8, 0x8c, 0x21, 0xe5,
	0x3e, 0xd2, 0xe2, 0x45, 0xd4, 0x1c, 0xb8, 0x39, 0x17, 0x18, 0x40, 0xb2, 0x6a, 0xb6, 0x99, 0xb0,
	0x38, 0x1d, 0xed, 0xd5, 0x3f, 0x45, 0xdd, 0x80, 0xd8, 0x83, 0x6c, 0xe3, 0x78, 0x20, 0xf5, 0x84,
	0xe1, 0xc7, 0x7d, 0xf1, 0x1e, 0x2b, 0x26, 0xe4, 0xc5, 0x40, 0x10, 0x44, 0xd6, 0x90, 0x36, 0x4f,
	0xea, 0xed, 0x1e, 0xab, 0x26, 0xad, 0x93, 0x26, 0xa9, 0x26, 0x59, 0x48, 0x91, 0x27, 0xe9, 0xec,
	0xb0, 0x48, 0xfa, 0xf4, 0xc2, 0x89, 0x50, 0xef, 0x0c, 0x4f, 0xa4, 0x6e, 0xbf, 0xd7, 0x1e, 0x92,
	0x33, 0x08, 0xf2, 0xe9, 0x49, 0xff, 0x14, 0x4b, 0x0a, 0xee, 0x20, 0xdf, 0x1e, 0x48, 0xf5, 0x56,
	0x4b, 0x94, 0x8e, 0xc5, 0xfe, 0x68, 0x50, 0x24, 0x35, 0x33, 0xdf, 0xe9, 0xd7, 0x5b, 0x52, 0xa3,
	0x8e, 0xe1, 0xd7, 0xc4, 0x55, 0x32, 0x84, 0xa1, 0x27, 0x00, 0xb0, 0x6e, 0xb8, 0xdf, 0x29, 0x66,
	0x89, 0x6c, 0xe4, 0x49, 0xea, 0x0a, 0xdd, 0x06, 0x7e, 0x97, 0xf3, 0x1b, 0x65, 0x82, 0x6d, 0x80,
	0x3c, 0xb9, 0x4c, 0x0b, 0x44, 0x4e, 0x7c, 0x1a, 0x0a, 0xc5, 0x3d, 0x5a, 0xdf, 0xc8, 0xa3, 0x58,
	0x2c, 0x12, 0x02, 0x5a, 0x39, 0xaf, 0x91, 0x55, 0xdd, 0xfa, 0x2a, 0x7c, 0x7b, 0x24, 0xa0, 0x6c,
	0x25, 0xc2, 0x7e, 0x38, 0xea, 0xf5, 0x84, 0x8e, 0x74, 0xbf, 0xdf, 0x13, 0x8a, 0xfb, 0x24, 0x39,
	0x9c, 0xa1, 0x1b, 0x5e, 0xf7, 0x33, 0xc2, 0x0d, 0xc2, 0xac, 0xdb, 0xa6, 0x27, 0x2b, 0xcf, 0x93,
	0xef, 0x3b, 0x07, 0xed, 0xde, 0xa9, 0x20, 0x0e, 0xdb, 0xfd, 0x5e, 0xf1, 0xc5, 0xc6, 0xd7, 0x60,
	0xcb, 0x7f, 0x5a, 0x68, 0xa4, 0x87, 0xee, 0x7f, 0x70, 0xf8, 0x4f, 0x00, 0x00, 0x00, 0xff, 0xff,
	0x13, 0xfd, 0x83, 0x72, 0xeb, 0x30, 0x00, 0x00,
}
